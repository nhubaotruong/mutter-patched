diff --git a/clutter/clutter/clutter-enums.h b/clutter/clutter/clutter-enums.h
index 45956bf57..8198e7351 100644
--- a/clutter/clutter/clutter-enums.h
+++ b/clutter/clutter/clutter-enums.h
@@ -1183,6 +1183,9 @@ typedef enum
   CLUTTER_INPUT_CONTENT_HINT_SENSITIVE_DATA      = 1 << 7,
   CLUTTER_INPUT_CONTENT_HINT_LATIN               = 1 << 8,
   CLUTTER_INPUT_CONTENT_HINT_MULTILINE           = 1 << 9,
+  CLUTTER_INPUT_CONTENT_HINT_DEFAULT             = 1 << 10,
+  CLUTTER_INPUT_CONTENT_HINT_PASSWORD            = 1 << 11,
+  CLUTTER_INPUT_CONTENT_HINT_AUTO_CORRECTION     = 1 << 12,
 } ClutterInputContentHintFlags;
 
 typedef enum
diff --git a/clutter/clutter/clutter-frame-clock.c b/clutter/clutter/clutter-frame-clock.c
index 30a319f60..3418cb86c 100644
--- a/clutter/clutter/clutter-frame-clock.c
+++ b/clutter/clutter/clutter-frame-clock.c
@@ -42,7 +42,16 @@ enum
 
 static guint signals[N_SIGNALS];
 
-#define SYNC_DELAY_FALLBACK_FRACTION 0.875
+typedef enum
+{
+  TRIPLE_BUFFERING_MODE_NEVER,
+  TRIPLE_BUFFERING_MODE_AUTO,
+  TRIPLE_BUFFERING_MODE_ALWAYS,
+} TripleBufferingMode;
+
+static TripleBufferingMode triple_buffering_mode = TRIPLE_BUFFERING_MODE_AUTO;
+
+#define SYNC_DELAY_FALLBACK_FRACTION 0.875f
 
 #define MINIMUM_REFRESH_RATE 30.f
 
@@ -70,8 +79,10 @@ typedef enum _ClutterFrameClockState
   CLUTTER_FRAME_CLOCK_STATE_IDLE,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED,
   CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW,
-  CLUTTER_FRAME_CLOCK_STATE_DISPATCHING,
-  CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW,
+  CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO,
 } ClutterFrameClockState;
 
 struct _ClutterFrameClock
@@ -92,6 +103,7 @@ struct _ClutterFrameClock
   ClutterFrameClockMode mode;
 
   int64_t last_dispatch_time_us;
+  int64_t prev_last_dispatch_time_us;
   int64_t last_dispatch_lateness_us;
   int64_t last_presentation_time_us;
   int64_t next_update_time_us;
@@ -113,6 +125,9 @@ struct _ClutterFrameClock
   int64_t vblank_duration_us;
   /* Last KMS buffer submission time. */
   int64_t last_flip_time_us;
+  int64_t prev_last_flip_time_us;
+
+  ClutterFrameHint last_flip_hints;
 
   /* Last time we promoted short-term maximum to long-term one */
   int64_t longterm_promotion_us;
@@ -137,6 +152,8 @@ struct _ClutterFrameClock
 
   int64_t last_dispatch_interval_us;
 
+  int64_t deadline_evasion_us;
+
   char *output_name;
 };
 
@@ -247,10 +264,6 @@ static void
 maybe_update_longterm_max_duration_us (ClutterFrameClock *frame_clock,
                                        ClutterFrameInfo  *frame_info)
 {
-  /* Do not update long-term max if there has been no measurement */
-  if (!frame_clock->shortterm_max_update_duration_us)
-    return;
-
   if ((frame_info->presentation_time - frame_clock->longterm_promotion_us) <
       G_USEC_PER_SEC)
     return;
@@ -277,6 +290,12 @@ void
 clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
                                       ClutterFrameInfo  *frame_info)
 {
+#ifdef CLUTTER_ENABLE_DEBUG
+  const char *debug_state =
+    frame_clock->state == CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO ?
+    "Triple buffering" : "Double buffering";
+#endif
+
   COGL_TRACE_BEGIN_SCOPED (ClutterFrameClockNotifyPresented,
                            "Clutter::FrameClock::presented()");
   COGL_TRACE_DESCRIBE (ClutterFrameClockNotifyPresented,
@@ -366,22 +385,54 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 
   frame_clock->got_measurements_last_frame = FALSE;
 
-  if (frame_info->cpu_time_before_buffer_swap_us != 0 &&
-      frame_info->has_valid_gpu_rendering_duration)
+  if ((frame_info->cpu_time_before_buffer_swap_us != 0 &&
+       frame_info->has_valid_gpu_rendering_duration) ||
+      frame_clock->ever_got_measurements)
     {
       int64_t dispatch_to_swap_us, swap_to_rendering_done_us, swap_to_flip_us;
+      int64_t dispatch_time_us = 0, flip_time_us = 0;
+
+      switch (frame_clock->state)
+        {
+        case CLUTTER_FRAME_CLOCK_STATE_INIT:
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+          g_warn_if_reached ();
+          G_GNUC_FALLTHROUGH;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+          dispatch_time_us = frame_clock->last_dispatch_time_us;
+          flip_time_us = frame_clock->last_flip_time_us;
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+          dispatch_time_us = frame_clock->prev_last_dispatch_time_us;
+          flip_time_us = frame_clock->prev_last_flip_time_us;
+          break;
+        }
 
-      dispatch_to_swap_us =
-        frame_info->cpu_time_before_buffer_swap_us -
-        frame_clock->last_dispatch_time_us;
+      if (frame_info->cpu_time_before_buffer_swap_us == 0)
+        {
+          /* User thread cursor-only updates with no "swap": we do know
+           * the combined time from dispatch to flip at least.
+           */
+          dispatch_to_swap_us = 0;
+          swap_to_flip_us = flip_time_us - dispatch_time_us;
+        }
+      else
+        {
+          dispatch_to_swap_us = frame_info->cpu_time_before_buffer_swap_us -
+                                dispatch_time_us;
+          swap_to_flip_us = flip_time_us -
+                            frame_info->cpu_time_before_buffer_swap_us;
+        }
       swap_to_rendering_done_us =
         frame_info->gpu_rendering_duration_ns / 1000;
-      swap_to_flip_us =
-        frame_clock->last_flip_time_us -
-        frame_info->cpu_time_before_buffer_swap_us;
 
       CLUTTER_NOTE (FRAME_TIMINGS,
-                    "update2dispatch %ld µs, dispatch2swap %ld µs, swap2render %ld µs, swap2flip %ld µs",
+                    "%s: update2dispatch %ld µs, dispatch2swap %ld µs, swap2render %ld µs, swap2flip %ld µs",
+                    debug_state,
                     frame_clock->last_dispatch_lateness_us,
                     dispatch_to_swap_us,
                     swap_to_rendering_done_us,
@@ -389,9 +440,10 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
 
       frame_clock->shortterm_max_update_duration_us =
         CLAMP (frame_clock->last_dispatch_lateness_us + dispatch_to_swap_us +
-               MAX (swap_to_rendering_done_us, swap_to_flip_us),
+               MAX (swap_to_rendering_done_us, swap_to_flip_us) +
+               frame_clock->deadline_evasion_us,
                frame_clock->shortterm_max_update_duration_us,
-               frame_clock->refresh_interval_us);
+               2 * frame_clock->refresh_interval_us);
 
       maybe_update_longterm_max_duration_us (frame_clock, frame_info);
 
@@ -400,7 +452,8 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     }
   else
     {
-      CLUTTER_NOTE (FRAME_TIMINGS, "update2dispatch %ld µs",
+      CLUTTER_NOTE (FRAME_TIMINGS, "%s: update2dispatch %ld µs",
+                    debug_state,
                     frame_clock->last_dispatch_lateness_us);
     }
 
@@ -418,11 +471,22 @@ clutter_frame_clock_notify_presented (ClutterFrameClock *frame_clock,
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
       g_warn_if_reached ();
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       maybe_reschedule_update (frame_clock);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      maybe_reschedule_update (frame_clock);
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
+      maybe_reschedule_update (frame_clock);
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+      maybe_reschedule_update (frame_clock);
+      break;
     }
 }
 
@@ -440,26 +504,37 @@ clutter_frame_clock_notify_ready (ClutterFrameClock *frame_clock)
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
       g_warn_if_reached ();
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       maybe_reschedule_update (frame_clock);
       break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+      maybe_reschedule_update (frame_clock);
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
+      maybe_reschedule_update (frame_clock);
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+      maybe_reschedule_update (frame_clock);
+      break;
     }
 }
 
-static int64_t
-clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
+static gboolean
+clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock,
+                                                int64_t           *max_render_time_us)
 {
   int64_t refresh_interval_us;
-  int64_t max_render_time_us;
 
   refresh_interval_us = frame_clock->refresh_interval_us;
 
   if (!frame_clock->ever_got_measurements ||
       G_UNLIKELY (clutter_paint_debug_flags &
                   CLUTTER_DEBUG_DISABLE_DYNAMIC_MAX_RENDER_TIME))
-    return refresh_interval_us * SYNC_DELAY_FALLBACK_FRACTION;
+    return FALSE;
 
   /* Max render time shows how early the frame clock needs to be dispatched
    * to make it to the predicted next presentation time. It is an estimate of
@@ -473,15 +548,15 @@ clutter_frame_clock_compute_max_render_time_us (ClutterFrameClock *frame_clock)
    * - The duration of vertical blank.
    * - A constant to account for variations in the above estimates.
    */
-  max_render_time_us =
+  *max_render_time_us =
     MAX (frame_clock->longterm_max_update_duration_us,
          frame_clock->shortterm_max_update_duration_us) +
     frame_clock->vblank_duration_us +
     clutter_max_render_time_constant_us;
 
-  max_render_time_us = CLAMP (max_render_time_us, 0, refresh_interval_us);
+  *max_render_time_us = CLAMP (*max_render_time_us, 0, 2 * refresh_interval_us);
 
-  return max_render_time_us;
+  return TRUE;
 }
 
 static void
@@ -496,7 +571,9 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
   int64_t min_render_time_allowed_us;
   int64_t max_render_time_allowed_us;
   int64_t next_presentation_time_us;
+  int64_t next_smooth_presentation_time_us = 0;
   int64_t next_update_time_us;
+  gboolean max_render_time_is_known;
 
   now_us = g_get_monotonic_time ();
 
@@ -516,10 +593,13 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
     }
 
   min_render_time_allowed_us = refresh_interval_us / 2;
-  max_render_time_allowed_us =
-    clutter_frame_clock_compute_max_render_time_us (frame_clock);
 
-  if (min_render_time_allowed_us > max_render_time_allowed_us)
+  max_render_time_is_known =
+    clutter_frame_clock_compute_max_render_time_us (frame_clock,
+                                                    &max_render_time_allowed_us);
+
+  if (max_render_time_is_known &&
+      min_render_time_allowed_us > max_render_time_allowed_us)
     min_render_time_allowed_us = max_render_time_allowed_us;
 
   /*
@@ -540,7 +620,29 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
    *
    */
   last_presentation_time_us = frame_clock->last_presentation_time_us;
-  next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+      next_smooth_presentation_time_us = last_presentation_time_us +
+                                         refresh_interval_us;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+      next_smooth_presentation_time_us = last_presentation_time_us +
+                                         2 * refresh_interval_us;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+      g_warn_if_reached ();  /* quad buffering would be a bug */
+      next_smooth_presentation_time_us = last_presentation_time_us +
+                                         3 * refresh_interval_us;
+      break;
+    }
+
+  next_presentation_time_us = next_smooth_presentation_time_us;
 
   /*
    * However, the last presentation could have happened more than a frame ago.
@@ -607,7 +709,7 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
     }
 
   if (frame_clock->last_presentation_flags & CLUTTER_FRAME_INFO_FLAG_VSYNC &&
-      next_presentation_time_us != last_presentation_time_us + refresh_interval_us)
+      next_presentation_time_us != next_smooth_presentation_time_us)
     {
       /* There was an idle period since the last presentation, so there seems
        * be no constantly updating actor. In this case it's best to start
@@ -619,6 +721,24 @@ calculate_next_update_time_us (ClutterFrameClock *frame_clock,
     }
   else
     {
+      /* If the max render time isn't known then using the current value of
+       * next_presentation_time_us is suboptimal. Targeting always one frame
+       * prior to that we'd lose the ability to scale up to triple buffering
+       * on late presentation. But targeting two frames prior we would be
+       * always triple buffering even when not required.
+       *   So the algorithm for deciding when to scale up to triple buffering
+       * in the absence of render time measurements is to simply target full
+       * frame rate. If we're keeping up then we'll stay double buffering. If
+       * we're not keeping up then this will switch us to triple buffering.
+       */
+      if (!max_render_time_is_known)
+        {
+          max_render_time_allowed_us =
+            (int64_t) (refresh_interval_us * SYNC_DELAY_FALLBACK_FRACTION);
+          next_presentation_time_us =
+            last_presentation_time_us + refresh_interval_us;
+        }
+
       while (next_presentation_time_us - min_render_time_allowed_us < now_us)
         next_presentation_time_us += refresh_interval_us;
 
@@ -650,7 +770,9 @@ calculate_next_variable_update_time_us (ClutterFrameClock *frame_clock,
 
   refresh_interval_us = frame_clock->refresh_interval_us;
 
-  if (frame_clock->last_presentation_time_us == 0)
+  if (frame_clock->last_presentation_time_us == 0 ||
+      !clutter_frame_clock_compute_max_render_time_us (frame_clock,
+                                                       &max_render_time_allowed_us))
     {
       *out_next_update_time_us =
         frame_clock->last_dispatch_time_us ?
@@ -663,9 +785,6 @@ calculate_next_variable_update_time_us (ClutterFrameClock *frame_clock,
       return;
     }
 
-  max_render_time_allowed_us =
-    clutter_frame_clock_compute_max_render_time_us (frame_clock);
-
   last_presentation_time_us = frame_clock->last_presentation_time_us;
   next_presentation_time_us = last_presentation_time_us + refresh_interval_us;
 
@@ -739,8 +858,17 @@ clutter_frame_clock_inhibit (ClutterFrameClock *frame_clock)
           frame_clock->pending_reschedule_now = TRUE;
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
           break;
-        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-        case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+          frame_clock->pending_reschedule = TRUE;
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+          frame_clock->pending_reschedule = TRUE;
+          frame_clock->pending_reschedule_now = TRUE;
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
           break;
         }
 
@@ -759,6 +887,25 @@ clutter_frame_clock_uninhibit (ClutterFrameClock *frame_clock)
     maybe_reschedule_update (frame_clock);
 }
 
+static gboolean
+want_triple_buffering (ClutterFrameClock *frame_clock)
+{
+  switch (triple_buffering_mode)
+    {
+    case TRIPLE_BUFFERING_MODE_NEVER:
+      return FALSE;
+    case TRIPLE_BUFFERING_MODE_AUTO:
+      return frame_clock->mode == CLUTTER_FRAME_CLOCK_MODE_FIXED &&
+             !(frame_clock->last_flip_hints &
+               CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED);
+    case TRIPLE_BUFFERING_MODE_ALWAYS:
+      return TRUE;
+    }
+
+  g_assert_not_reached ();
+  return FALSE;
+}
+
 void
 clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 {
@@ -776,11 +923,24 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
       return;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+      frame_clock->state =
+        CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+      if (want_triple_buffering (frame_clock))
+        {
+          frame_clock->state =
+            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW;
+          break;
+        }
+      G_GNUC_FALLTHROUGH;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
       frame_clock->pending_reschedule = TRUE;
       frame_clock->pending_reschedule_now = TRUE;
       return;
@@ -809,13 +969,17 @@ clutter_frame_clock_schedule_update_now (ClutterFrameClock *frame_clock)
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
 }
 
 void
 clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
 {
   int64_t next_update_time_us = -1;
+  TripleBufferingMode current_mode = triple_buffering_mode;
+
+  if (current_mode == TRIPLE_BUFFERING_MODE_AUTO &&
+      !want_triple_buffering (frame_clock))
+    current_mode = TRIPLE_BUFFERING_MODE_NEVER;
 
   if (frame_clock->inhibit_count > 0)
     {
@@ -831,12 +995,33 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
       return;
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
       return;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+      switch (current_mode)
+        {
+        case TRIPLE_BUFFERING_MODE_NEVER:
+          frame_clock->pending_reschedule = TRUE;
+          return;
+        case TRIPLE_BUFFERING_MODE_AUTO:
+          frame_clock->state =
+            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED;
+          break;
+        case TRIPLE_BUFFERING_MODE_ALWAYS:
+          next_update_time_us = g_get_monotonic_time ();
+          frame_clock->next_presentation_time_us = 0;
+          frame_clock->is_next_presentation_time_valid = FALSE;
+          frame_clock->state =
+            CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED;
+          goto got_update_time;
+        }
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
       frame_clock->pending_reschedule = TRUE;
       return;
     }
@@ -861,11 +1046,11 @@ clutter_frame_clock_schedule_update (ClutterFrameClock *frame_clock)
       break;
     }
 
+got_update_time:
   g_warn_if_fail (next_update_time_us != -1);
 
   frame_clock->next_update_time_us = next_update_time_us;
   g_source_set_ready_time (frame_clock->source, next_update_time_us);
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
 }
 
 void
@@ -881,6 +1066,8 @@ clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
     {
     case CLUTTER_FRAME_CLOCK_STATE_INIT:
     case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
       break;
     case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
       frame_clock->pending_reschedule = TRUE;
@@ -891,8 +1078,14 @@ clutter_frame_clock_set_mode (ClutterFrameClock     *frame_clock,
       frame_clock->pending_reschedule_now = TRUE;
       frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+      frame_clock->pending_reschedule = TRUE;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+      frame_clock->pending_reschedule = TRUE;
+      frame_clock->pending_reschedule_now = TRUE;
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
       break;
     }
 
@@ -928,7 +1121,7 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
                              frame_clock->refresh_interval_us;
 
   lateness_us = time_us - ideal_dispatch_time_us;
-  if (lateness_us < 0 || lateness_us >= frame_clock->refresh_interval_us)
+  if (lateness_us < 0 || lateness_us >= frame_clock->refresh_interval_us / 4)
     frame_clock->last_dispatch_lateness_us = 0;
   else
     frame_clock->last_dispatch_lateness_us = lateness_us;
@@ -949,10 +1142,27 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
     }
 #endif
 
+  frame_clock->prev_last_dispatch_time_us = frame_clock->last_dispatch_time_us;
   frame_clock->last_dispatch_time_us = time_us;
   g_source_set_ready_time (frame_clock->source, -1);
 
-  frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHING;
+  switch (frame_clock->state)
+    {
+    case CLUTTER_FRAME_CLOCK_STATE_INIT:
+    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+      g_warn_if_reached ();
+      return;
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+      break;
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+      frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO;
+      break;
+    }
 
   frame_count = frame_clock->frame_count++;
 
@@ -983,26 +1193,36 @@ clutter_frame_clock_dispatch (ClutterFrameClock *frame_clock,
   result = iface->frame (frame_clock, frame, frame_clock->listener.user_data);
   COGL_TRACE_END (ClutterFrameClockFrame);
 
-  switch (frame_clock->state)
+  switch (result)
     {
-    case CLUTTER_FRAME_CLOCK_STATE_INIT:
-    case CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED:
-      g_warn_if_reached ();
-      break;
-    case CLUTTER_FRAME_CLOCK_STATE_IDLE:
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
-    case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+    case CLUTTER_FRAME_RESULT_PENDING_PRESENTED:
       break;
-    case CLUTTER_FRAME_CLOCK_STATE_DISPATCHING:
-      switch (result)
+    case CLUTTER_FRAME_RESULT_IDLE:
+      /* The frame was aborted; nothing to paint/present */
+      switch (frame_clock->state)
         {
-        case CLUTTER_FRAME_RESULT_PENDING_PRESENTED:
-          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_PENDING_PRESENTED;
+        case CLUTTER_FRAME_CLOCK_STATE_INIT:
+        case CLUTTER_FRAME_CLOCK_STATE_IDLE:
+        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED:
+        case CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW:
+          g_warn_if_reached ();
           break;
-        case CLUTTER_FRAME_RESULT_IDLE:
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE:
           frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_IDLE;
           maybe_reschedule_update (frame_clock);
           break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED;
+          maybe_reschedule_update (frame_clock);
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE_AND_SCHEDULED_NOW:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_SCHEDULED_NOW;
+          maybe_reschedule_update (frame_clock);
+          break;
+        case CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_TWO:
+          frame_clock->state = CLUTTER_FRAME_CLOCK_STATE_DISPATCHED_ONE;
+          maybe_reschedule_update (frame_clock);
+          break;
         }
       break;
     }
@@ -1035,21 +1255,31 @@ frame_clock_source_dispatch (GSource     *source,
 }
 
 void
-clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
-                                      int64_t            flip_time_us)
+clutter_frame_clock_record_flip (ClutterFrameClock *frame_clock,
+                                 int64_t            flip_time_us,
+                                 ClutterFrameHint   hints)
 {
+  frame_clock->prev_last_flip_time_us = frame_clock->last_flip_time_us;
   frame_clock->last_flip_time_us = flip_time_us;
+  frame_clock->last_flip_hints = hints;
 }
 
 GString *
 clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock)
 {
+  int64_t max_render_time_us;
   int64_t max_update_duration_us;
   GString *string;
 
-  string = g_string_new (NULL);
-  g_string_append_printf (string, "Max render time: %ld µs",
-                          clutter_frame_clock_compute_max_render_time_us (frame_clock));
+  string = g_string_new ("Max render time: ");
+  if (!clutter_frame_clock_compute_max_render_time_us (frame_clock,
+                                                       &max_render_time_us))
+    {
+      g_string_append (string, "unknown");
+      return string;
+    }
+
+  g_string_append_printf (string, "%ld µs", max_render_time_us);
 
   if (frame_clock->got_measurements_last_frame)
     g_string_append_printf (string, " =");
@@ -1216,8 +1446,6 @@ clutter_frame_clock_dispose (GObject *object)
 {
   ClutterFrameClock *frame_clock = CLUTTER_FRAME_CLOCK (object);
 
-  g_warn_if_fail (frame_clock->state != CLUTTER_FRAME_CLOCK_STATE_DISPATCHING);
-
   if (frame_clock->source)
     {
       g_signal_emit (frame_clock, signals[DESTROY], 0);
@@ -1241,6 +1469,15 @@ static void
 clutter_frame_clock_class_init (ClutterFrameClockClass *klass)
 {
   GObjectClass *object_class = G_OBJECT_CLASS (klass);
+  const char *mode_str;
+
+  mode_str = g_getenv ("MUTTER_DEBUG_TRIPLE_BUFFERING");
+  if (!g_strcmp0 (mode_str, "never"))
+    triple_buffering_mode = TRIPLE_BUFFERING_MODE_NEVER;
+  else if (!g_strcmp0 (mode_str, "auto"))
+    triple_buffering_mode = TRIPLE_BUFFERING_MODE_AUTO;
+  else if (!g_strcmp0 (mode_str, "always"))
+    triple_buffering_mode = TRIPLE_BUFFERING_MODE_ALWAYS;
 
   object_class->dispose = clutter_frame_clock_dispose;
 
@@ -1253,3 +1490,10 @@ clutter_frame_clock_class_init (ClutterFrameClockClass *klass)
                   G_TYPE_NONE,
                   0);
 }
+
+void
+clutter_frame_clock_set_deadline_evasion (ClutterFrameClock *frame_clock,
+                                          int64_t            deadline_evasion_us)
+{
+  frame_clock->deadline_evasion_us = deadline_evasion_us;
+}
diff --git a/clutter/clutter/clutter-frame-clock.h b/clutter/clutter/clutter-frame-clock.h
index a7be5ef31..23e3357d3 100644
--- a/clutter/clutter/clutter-frame-clock.h
+++ b/clutter/clutter/clutter-frame-clock.h
@@ -33,6 +33,12 @@ typedef enum _ClutterFrameResult
   CLUTTER_FRAME_RESULT_IDLE,
 } ClutterFrameResult;
 
+typedef enum _ClutterFrameHint
+{
+  CLUTTER_FRAME_HINT_NONE                     = 0,
+  CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED = 1 << 0,
+} ClutterFrameHint;
+
 #define CLUTTER_TYPE_FRAME_CLOCK (clutter_frame_clock_get_type ())
 CLUTTER_EXPORT
 G_DECLARE_FINAL_TYPE (ClutterFrameClock, clutter_frame_clock,
@@ -102,7 +108,12 @@ void clutter_frame_clock_remove_timeline (ClutterFrameClock *frame_clock,
 CLUTTER_EXPORT
 float clutter_frame_clock_get_refresh_rate (ClutterFrameClock *frame_clock);
 
-void clutter_frame_clock_record_flip_time (ClutterFrameClock *frame_clock,
-                                           int64_t            flip_time_us);
+void clutter_frame_clock_record_flip (ClutterFrameClock *frame_clock,
+                                      int64_t            flip_time_us,
+                                      ClutterFrameHint   hints);
 
 GString * clutter_frame_clock_get_max_render_time_debug_info (ClutterFrameClock *frame_clock);
+
+CLUTTER_EXPORT
+void clutter_frame_clock_set_deadline_evasion (ClutterFrameClock *frame_clock,
+                                               int64_t            deadline_evasion_us);
diff --git a/clutter/clutter/clutter-frame-private.h b/clutter/clutter/clutter-frame-private.h
index ef66b874e..ce140560a 100644
--- a/clutter/clutter/clutter-frame-private.h
+++ b/clutter/clutter/clutter-frame-private.h
@@ -36,6 +36,7 @@ struct _ClutterFrame
 
   gboolean has_result;
   ClutterFrameResult result;
+  ClutterFrameHint hints;
 };
 
 CLUTTER_EXPORT
diff --git a/clutter/clutter/clutter-frame.c b/clutter/clutter/clutter-frame.c
index 7436f9f18..53c289b2c 100644
--- a/clutter/clutter/clutter-frame.c
+++ b/clutter/clutter/clutter-frame.c
@@ -115,3 +115,16 @@ clutter_frame_set_result (ClutterFrame       *frame,
   frame->result = result;
   frame->has_result = TRUE;
 }
+
+void
+clutter_frame_set_hint (ClutterFrame     *frame,
+                        ClutterFrameHint  hint)
+{
+  frame->hints |= hint;
+}
+
+ClutterFrameHint
+clutter_frame_get_hints (ClutterFrame *frame)
+{
+  return frame->hints;
+}
diff --git a/clutter/clutter/clutter-frame.h b/clutter/clutter/clutter-frame.h
index 34f0770bd..c7b3d02ac 100644
--- a/clutter/clutter/clutter-frame.h
+++ b/clutter/clutter/clutter-frame.h
@@ -54,4 +54,11 @@ void clutter_frame_set_result (ClutterFrame       *frame,
 CLUTTER_EXPORT
 gboolean clutter_frame_has_result (ClutterFrame *frame);
 
+CLUTTER_EXPORT
+void clutter_frame_set_hint (ClutterFrame     *frame,
+                             ClutterFrameHint  hint);
+
+CLUTTER_EXPORT
+ClutterFrameHint clutter_frame_get_hints (ClutterFrame *frame);
+
 G_DEFINE_AUTOPTR_CLEANUP_FUNC (ClutterFrame, clutter_frame_unref)
diff --git a/clutter/clutter/clutter-stage-view.c b/clutter/clutter/clutter-stage-view.c
index f5188e2ac..a89a520ef 100644
--- a/clutter/clutter/clutter-stage-view.c
+++ b/clutter/clutter/clutter-stage-view.c
@@ -740,6 +740,10 @@ clutter_stage_view_schedule_update (ClutterStageView *view)
 {
   ClutterStageViewPrivate *priv =
     clutter_stage_view_get_instance_private (view);
+  ClutterStageViewClass *view_class = CLUTTER_STAGE_VIEW_GET_CLASS (view);
+
+  if (view_class->schedule_update)
+    view_class->schedule_update (view);
 
   clutter_frame_clock_schedule_update (priv->frame_clock);
 }
@@ -898,14 +902,21 @@ handle_frame_clock_frame (ClutterFrameClock *frame_clock,
 
       _clutter_stage_window_redraw_view (stage_window, view, frame);
 
-      clutter_frame_clock_record_flip_time (frame_clock,
-                                            g_get_monotonic_time ());
+      clutter_frame_clock_record_flip (frame_clock,
+                                       g_get_monotonic_time (),
+                                       clutter_frame_get_hints (frame));
 
       clutter_stage_emit_after_paint (stage, view, frame);
 
       if (_clutter_context_get_show_fps ())
         end_frame_timing_measurement (view);
     }
+  else
+    {
+      clutter_frame_clock_record_flip (frame_clock,
+                                       g_get_monotonic_time (),
+                                       clutter_frame_get_hints (frame));
+    }
 
   _clutter_stage_window_finish_frame (stage_window, view, frame);
 
diff --git a/clutter/clutter/clutter-stage-view.h b/clutter/clutter/clutter-stage-view.h
index c0888f7f9..bdaa065c0 100644
--- a/clutter/clutter/clutter-stage-view.h
+++ b/clutter/clutter/clutter-stage-view.h
@@ -54,6 +54,8 @@ struct _ClutterStageViewClass
   ClutterFrame * (* new_frame) (ClutterStageView *view);
 
   ClutterPaintFlag (* get_default_paint_flags) (ClutterStageView *view);
+
+  void (* schedule_update) (ClutterStageView *view);
 };
 
 CLUTTER_EXPORT
diff --git a/cogl/cogl/cogl-onscreen-private.h b/cogl/cogl/cogl-onscreen-private.h
index 959a60533..cfd45a625 100644
--- a/cogl/cogl/cogl-onscreen-private.h
+++ b/cogl/cogl/cogl-onscreen-private.h
@@ -78,4 +78,7 @@ COGL_EXPORT CoglFrameInfo *
 cogl_onscreen_peek_tail_frame_info (CoglOnscreen *onscreen);
 
 COGL_EXPORT CoglFrameInfo *
-cogl_onscreen_pop_head_frame_info (CoglOnscreen *onscreen);
+cogl_onscreen_pop_head_frame_info  (CoglOnscreen *onscreen);
+
+COGL_EXPORT unsigned int
+cogl_onscreen_get_pending_frame_count (CoglOnscreen *onscreen);
diff --git a/cogl/cogl/cogl-onscreen.c b/cogl/cogl/cogl-onscreen.c
index e2b3a0b46..53ffa649b 100644
--- a/cogl/cogl/cogl-onscreen.c
+++ b/cogl/cogl/cogl-onscreen.c
@@ -514,6 +514,14 @@ cogl_onscreen_pop_head_frame_info (CoglOnscreen *onscreen)
   return g_queue_pop_head (&priv->pending_frame_infos);
 }
 
+unsigned int
+cogl_onscreen_get_pending_frame_count (CoglOnscreen *onscreen)
+{
+  CoglOnscreenPrivate *priv = cogl_onscreen_get_instance_private (onscreen);
+
+  return g_queue_get_length (&priv->pending_frame_infos);
+}
+
 CoglFrameClosure *
 cogl_onscreen_add_frame_callback (CoglOnscreen *onscreen,
                                   CoglFrameCallback callback,
diff --git a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
index b05337d74..7294c57a8 100644
--- a/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
+++ b/data/dbus-interfaces/org.gnome.Mutter.DisplayConfig.xml
@@ -426,10 +426,6 @@
 				       always use the same scale. Absence of
 				       this means logical monitor scales can
 				       differ.
-	* "legacy-ui-scaling-factor" (i): The legacy scaling factor traditionally
-				          used to scale X11 clients (commonly
-					  communicated via the
-					  Gdk/WindowScalingFactor XSetting entry).
     -->
     <method name="GetCurrentState">
       <arg name="serial" direction="out" type="u" />
diff --git a/data/dbus-interfaces/org.gnome.Mutter.X11.xml b/data/dbus-interfaces/org.gnome.Mutter.X11.xml
new file mode 100644
index 000000000..3d3c8a42f
--- /dev/null
+++ b/data/dbus-interfaces/org.gnome.Mutter.X11.xml
@@ -0,0 +1,8 @@
+<!DOCTYPE node PUBLIC
+'-//freedesktop//DTD D-BUS Object Introspection 1.0//EN'
+'http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd'>
+<node>
+  <interface name="org.gnome.Mutter.X11">
+    <property name="UiScalingFactor" type="i" access="readwrite" />
+  </interface>
+</node>
diff --git a/data/org.gnome.mutter.gschema.xml.in b/data/org.gnome.mutter.gschema.xml.in
index 92c97b12e..6751a8d7a 100644
--- a/data/org.gnome.mutter.gschema.xml.in
+++ b/data/org.gnome.mutter.gschema.xml.in
@@ -5,6 +5,7 @@
     <value nick="kms-modifiers" value="2"/>
     <value nick="autoclose-xwayland" value="4"/>
     <value nick="variable-refresh-rate" value="8"/>
+    <value nick="xwayland-native-scaling" value="16"/>
   </flags>
 
   <schema id="org.gnome.mutter" path="/org/gnome/mutter/"
@@ -136,6 +137,12 @@
                                         GPU and DRM driver. Configurable in
                                         Settings. Requires a restart.
 
+        • “xwayland-native-scaling”   — lets Xwayland clients use their native
+                                        scaling support. If scaling is not
+                                        supported by client, the client will
+                                        be unscaled. Setting only takes effect
+                                        when “scale-monitor-framebuffer” is
+                                        enabled as well.
       </description>
     </key>
 
diff --git a/src/backends/meta-egl.c b/src/backends/meta-egl.c
index cc023f705..bc188e80e 100644
--- a/src/backends/meta-egl.c
+++ b/src/backends/meta-egl.c
@@ -44,6 +44,11 @@ struct _MetaEgl
   PFNEGLCREATEIMAGEKHRPROC eglCreateImageKHR;
   PFNEGLDESTROYIMAGEKHRPROC eglDestroyImageKHR;
 
+  PFNEGLCREATESYNCPROC eglCreateSync;
+  PFNEGLDESTROYSYNCPROC eglDestroySync;
+  PFNEGLWAITSYNCPROC eglWaitSync;
+  PFNEGLDUPNATIVEFENCEFDANDROIDPROC eglDupNativeFenceFDANDROID;
+
   PFNEGLBINDWAYLANDDISPLAYWL eglBindWaylandDisplayWL;
   PFNEGLQUERYWAYLANDBUFFERWL eglQueryWaylandBufferWL;
 
@@ -1162,6 +1167,90 @@ meta_egl_query_display_attrib (MetaEgl     *egl,
   return TRUE;
 }
 
+gboolean
+meta_egl_create_sync (MetaEgl           *egl,
+                      EGLDisplay         display,
+                      EGLenum            type,
+                      const EGLAttrib   *attrib_list,
+                      EGLSync           *egl_sync,
+                      GError           **error)
+{
+  if (!is_egl_proc_valid (egl->eglCreateSync, error))
+    return FALSE;
+
+  EGLSync sync;
+
+  sync = egl->eglCreateSync (display, type, attrib_list);
+
+  if (sync == EGL_NO_SYNC)
+    {
+      set_egl_error (error);
+      return FALSE;
+    }
+
+  *egl_sync = sync;
+
+  return TRUE;
+}
+
+gboolean
+meta_egl_destroy_sync (MetaEgl     *egl,
+                       EGLDisplay   display,
+                       EGLSync      sync,
+                       GError     **error)
+{
+  if (!is_egl_proc_valid (egl->eglDestroySync, error))
+    return FALSE;
+
+  if (!egl->eglDestroySync (display, sync))
+    {
+      set_egl_error (error);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+gboolean
+meta_egl_wait_sync (MetaEgl     *egl,
+                    EGLDisplay   display,
+                    EGLSync      sync,
+                    EGLint       flags,
+                    GError     **error)
+{
+  if (!is_egl_proc_valid (egl->eglWaitSync, error))
+    return FALSE;
+
+  if (!egl->eglWaitSync (display, sync, flags))
+    {
+      set_egl_error (error);
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+EGLint
+meta_egl_duplicate_native_fence_fd (MetaEgl     *egl,
+                                    EGLDisplay   display,
+                                    EGLSync      sync,
+                                    GError     **error)
+{
+  if (!is_egl_proc_valid (egl->eglDupNativeFenceFDANDROID, error))
+    return EGL_NO_NATIVE_FENCE_FD_ANDROID;
+
+  EGLint fd = EGL_NO_NATIVE_FENCE_FD_ANDROID;
+
+  fd = egl->eglDupNativeFenceFDANDROID (display, sync);
+
+  if (fd == EGL_NO_NATIVE_FENCE_FD_ANDROID)
+    {
+      set_egl_error (error);
+    }
+
+  return fd;
+}
+
 #define GET_EGL_PROC_ADDR(proc) \
   egl->proc = (void *) eglGetProcAddress (#proc);
 
@@ -1175,6 +1264,11 @@ meta_egl_constructed (GObject *object)
   GET_EGL_PROC_ADDR (eglCreateImageKHR);
   GET_EGL_PROC_ADDR (eglDestroyImageKHR);
 
+  GET_EGL_PROC_ADDR (eglCreateSync);
+  GET_EGL_PROC_ADDR (eglDestroySync);
+  GET_EGL_PROC_ADDR (eglWaitSync);
+  GET_EGL_PROC_ADDR (eglDupNativeFenceFDANDROID);
+
   GET_EGL_PROC_ADDR (eglBindWaylandDisplayWL);
   GET_EGL_PROC_ADDR (eglQueryWaylandBufferWL);
 
diff --git a/src/backends/meta-egl.h b/src/backends/meta-egl.h
index 8b955c90c..9078b4794 100644
--- a/src/backends/meta-egl.h
+++ b/src/backends/meta-egl.h
@@ -276,3 +276,26 @@ gboolean meta_egl_query_display_attrib (MetaEgl     *egl,
                                         EGLint       attribute,
                                         EGLAttrib   *value,
                                         GError     **error);
+
+gboolean meta_egl_create_sync (MetaEgl           *egl,
+                               EGLDisplay         display,
+                               EGLenum            type,
+                               const EGLAttrib   *attrib_list,
+                               EGLSync           *egl_sync,
+                               GError           **error);
+
+gboolean meta_egl_destroy_sync (MetaEgl     *egl,
+                                EGLDisplay   display,
+                                EGLSync      sync,
+                                GError     **error);
+
+gboolean meta_egl_wait_sync (MetaEgl     *egl,
+                             EGLDisplay   display,
+                             EGLSync      sync,
+                             EGLint       flags,
+                             GError     **error);
+
+EGLint meta_egl_duplicate_native_fence_fd (MetaEgl     *egl,
+                                           EGLDisplay   display,
+                                           EGLSync      sync,
+                                           GError     **error);
diff --git a/src/backends/meta-monitor-manager-private.h b/src/backends/meta-monitor-manager-private.h
index 0760a341a..6ed3fc2c3 100644
--- a/src/backends/meta-monitor-manager-private.h
+++ b/src/backends/meta-monitor-manager-private.h
@@ -436,3 +436,5 @@ gboolean meta_monitor_manager_apply_monitors_config (MetaMonitorManager        *
                                                      MetaMonitorsConfig        *config,
                                                      MetaMonitorsConfigMethod   method,
                                                      GError                   **error);
+
+MetaLogicalMonitorLayoutMode meta_monitor_manager_get_layout_mode (MetaMonitorManager *manager);
diff --git a/src/backends/meta-monitor-manager.c b/src/backends/meta-monitor-manager.c
index 77743bc72..45033d966 100644
--- a/src/backends/meta-monitor-manager.c
+++ b/src/backends/meta-monitor-manager.c
@@ -2051,14 +2051,12 @@ meta_monitor_manager_handle_get_current_state (MetaDBusDisplayConfig *skeleton,
                                                GDBusMethodInvocation *invocation,
                                                MetaMonitorManager    *manager)
 {
-  MetaSettings *settings = meta_backend_get_settings (manager->backend);
   GVariantBuilder monitors_builder;
   GVariantBuilder logical_monitors_builder;
   GVariantBuilder properties_builder;
   GList *l;
   int i;
   MetaMonitorManagerCapability capabilities;
-  int ui_scaling_factor;
   int max_screen_width, max_screen_height;
 
   g_variant_builder_init (&monitors_builder,
@@ -2261,11 +2259,6 @@ meta_monitor_manager_handle_get_current_state (MetaDBusDisplayConfig *skeleton,
                              g_variant_new_boolean (TRUE));
     }
 
-  ui_scaling_factor = meta_settings_get_ui_scaling_factor (settings);
-  g_variant_builder_add (&properties_builder, "{sv}",
-                         "legacy-ui-scaling-factor",
-                         g_variant_new_int32 (ui_scaling_factor));
-
   if (meta_monitor_manager_get_max_screen_size (manager,
                                                 &max_screen_width,
                                                 &max_screen_height))
@@ -4123,3 +4116,9 @@ meta_monitor_manager_get_virtual_monitors (MetaMonitorManager *manager)
 
   return priv->virtual_monitors;
 }
+
+MetaLogicalMonitorLayoutMode
+meta_monitor_manager_get_layout_mode (MetaMonitorManager *manager)
+{
+  return manager->layout_mode;
+}
diff --git a/src/backends/meta-settings-private.h b/src/backends/meta-settings-private.h
index afbba054a..2081a81b1 100644
--- a/src/backends/meta-settings-private.h
+++ b/src/backends/meta-settings-private.h
@@ -32,6 +32,7 @@ typedef enum _MetaExperimentalFeature
   META_EXPERIMENTAL_FEATURE_KMS_MODIFIERS  = (1 << 1),
   META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND  = (1 << 2),
   META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE = (1 << 3),
+  META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING  = (1 << 4),
 } MetaExperimentalFeature;
 
 typedef enum _MetaXwaylandExtension
diff --git a/src/backends/meta-settings.c b/src/backends/meta-settings.c
index 3703b23b0..1ae59d636 100644
--- a/src/backends/meta-settings.c
+++ b/src/backends/meta-settings.c
@@ -296,6 +296,8 @@ experimental_features_handler (GVariant *features_variant,
         feature = META_EXPERIMENTAL_FEATURE_AUTOCLOSE_XWAYLAND;
       else if (g_str_equal (feature_str, "variable-refresh-rate"))
         feature = META_EXPERIMENTAL_FEATURE_VARIABLE_REFRESH_RATE;
+      else if (g_str_equal (feature_str, "xwayland-native-scaling"))
+        feature = META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING;
 
       if (feature)
         g_message ("Enabling experimental feature '%s'", feature_str);
diff --git a/src/backends/meta-stage-impl.c b/src/backends/meta-stage-impl.c
index 7aa24439d..727e1a5f3 100644
--- a/src/backends/meta-stage-impl.c
+++ b/src/backends/meta-stage-impl.c
@@ -774,6 +774,8 @@ meta_stage_impl_redraw_view (ClutterStageWindow *stage_window,
     {
       g_autoptr (GError) error = NULL;
 
+      clutter_frame_set_hint (frame, CLUTTER_FRAME_HINT_DIRECT_SCANOUT_ATTEMPTED);
+
       if (meta_stage_impl_scanout_view (stage_impl,
                                         stage_view,
                                         scanout,
diff --git a/src/backends/native/meta-crtc-kms.c b/src/backends/native/meta-crtc-kms.c
index 3498f922a..8cb0e935a 100644
--- a/src/backends/native/meta-crtc-kms.c
+++ b/src/backends/native/meta-crtc-kms.c
@@ -348,6 +348,15 @@ meta_crtc_kms_is_hw_cursor_supported (MetaCrtcNative *crtc_native)
   return meta_kms_device_has_cursor_plane_for (kms_device, kms_crtc);
 }
 
+static int64_t
+meta_crtc_kms_get_deadline_evasion (MetaCrtcNative *crtc_native)
+{
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc_native);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+
+  return meta_kms_crtc_get_deadline_evasion (kms_crtc);
+}
+
 MetaKmsPlane *
 meta_crtc_kms_get_assigned_cursor_plane (MetaCrtcKms *crtc_kms)
 {
@@ -479,6 +488,7 @@ meta_crtc_kms_class_init (MetaCrtcKmsClass *klass)
 
   crtc_native_class->is_transform_handled = meta_crtc_kms_is_transform_handled;
   crtc_native_class->is_hw_cursor_supported = meta_crtc_kms_is_hw_cursor_supported;
+  crtc_native_class->get_deadline_evasion = meta_crtc_kms_get_deadline_evasion;
 
   signals[GAMMA_LUT_CHANGED] =
     g_signal_new ("gamma-lut-changed",
diff --git a/src/backends/native/meta-crtc-native.c b/src/backends/native/meta-crtc-native.c
index fc280f696..80406a503 100644
--- a/src/backends/native/meta-crtc-native.c
+++ b/src/backends/native/meta-crtc-native.c
@@ -39,6 +39,14 @@ meta_crtc_native_is_hw_cursor_supported (MetaCrtcNative *crtc_native)
   return klass->is_hw_cursor_supported (crtc_native);
 }
 
+int64_t
+meta_crtc_native_get_deadline_evasion (MetaCrtcNative *crtc_native)
+{
+  MetaCrtcNativeClass *klass = META_CRTC_NATIVE_GET_CLASS (crtc_native);
+
+  return klass->get_deadline_evasion (crtc_native);
+}
+
 static void
 meta_crtc_native_init (MetaCrtcNative *crtc_native)
 {
diff --git a/src/backends/native/meta-crtc-native.h b/src/backends/native/meta-crtc-native.h
index 3fb4bc758..1f9a2ed46 100644
--- a/src/backends/native/meta-crtc-native.h
+++ b/src/backends/native/meta-crtc-native.h
@@ -31,9 +31,12 @@ struct _MetaCrtcNativeClass
   gboolean (* is_transform_handled) (MetaCrtcNative       *crtc_native,
                                      MetaMonitorTransform  monitor_transform);
   gboolean (* is_hw_cursor_supported) (MetaCrtcNative *crtc_native);
+  int64_t (* get_deadline_evasion) (MetaCrtcNative *crtc_native);
 };
 
 gboolean meta_crtc_native_is_transform_handled (MetaCrtcNative       *crtc_native,
                                                 MetaMonitorTransform  transform);
 
 gboolean meta_crtc_native_is_hw_cursor_supported (MetaCrtcNative *crtc_native);
+
+int64_t meta_crtc_native_get_deadline_evasion (MetaCrtcNative *crtc_native);
diff --git a/src/backends/native/meta-crtc-virtual.c b/src/backends/native/meta-crtc-virtual.c
index 76165eb1b..00b599c61 100644
--- a/src/backends/native/meta-crtc-virtual.c
+++ b/src/backends/native/meta-crtc-virtual.c
@@ -70,6 +70,12 @@ meta_crtc_virtual_is_hw_cursor_supported (MetaCrtcNative *crtc_native)
   return TRUE;
 }
 
+static int64_t
+meta_crtc_virtual_get_deadline_evasion (MetaCrtcNative *crtc_native)
+{
+  return 0;
+}
+
 static void
 meta_crtc_virtual_init (MetaCrtcVirtual *crtc_virtual)
 {
@@ -89,4 +95,6 @@ meta_crtc_virtual_class_init (MetaCrtcVirtualClass *klass)
     meta_crtc_virtual_is_transform_handled;
   crtc_native_class->is_hw_cursor_supported =
     meta_crtc_virtual_is_hw_cursor_supported;
+  crtc_native_class->get_deadline_evasion =
+    meta_crtc_virtual_get_deadline_evasion;
 }
diff --git a/src/backends/native/meta-frame-native.c b/src/backends/native/meta-frame-native.c
index 146144db0..8dc9dba9b 100644
--- a/src/backends/native/meta-frame-native.c
+++ b/src/backends/native/meta-frame-native.c
@@ -27,7 +27,15 @@ struct _MetaFrameNative
 {
   ClutterFrame base;
 
+  MetaDrmBuffer *buffer;
+  CoglScanout *scanout;
+
   MetaKmsUpdate *kms_update;
+
+  struct {
+    int n_rectangles;
+    int *rectangles;  /* 4 x n_rectangles */
+  } damage;
 };
 
 static void
@@ -35,6 +43,10 @@ meta_frame_native_release (ClutterFrame *frame)
 {
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
 
+  g_clear_pointer (&frame_native->damage.rectangles, g_free);
+  g_clear_object (&frame_native->buffer);
+  g_clear_object (&frame_native->scanout);
+
   g_return_if_fail (!frame_native->kms_update);
 }
 
@@ -76,3 +88,54 @@ meta_frame_native_has_kms_update (MetaFrameNative *frame_native)
 {
   return !!frame_native->kms_update;
 }
+
+void
+meta_frame_native_set_buffer (MetaFrameNative *frame_native,
+                              MetaDrmBuffer   *buffer)
+{
+  g_set_object (&frame_native->buffer, buffer);
+}
+
+MetaDrmBuffer *
+meta_frame_native_get_buffer (MetaFrameNative *frame_native)
+{
+  return frame_native->buffer;
+}
+
+void
+meta_frame_native_set_scanout (MetaFrameNative *frame_native,
+                               CoglScanout     *scanout)
+{
+  g_set_object (&frame_native->scanout, scanout);
+}
+
+CoglScanout *
+meta_frame_native_get_scanout (MetaFrameNative *frame_native)
+{
+  return frame_native->scanout;
+}
+
+void
+meta_frame_native_set_damage (MetaFrameNative *frame_native,
+                              const int       *rectangles,
+                              int              n_rectangles)
+{
+  size_t rectangles_size;
+
+  rectangles_size = n_rectangles * 4 * sizeof (int);
+
+  frame_native->damage.rectangles =
+    g_realloc (frame_native->damage.rectangles, rectangles_size);
+  memcpy (frame_native->damage.rectangles, rectangles, rectangles_size);
+  frame_native->damage.n_rectangles = n_rectangles;
+}
+
+int
+meta_frame_native_get_damage (MetaFrameNative  *frame_native,
+                              int             **rectangles)
+{
+  if (rectangles)
+    *rectangles = frame_native->damage.rectangles;
+
+  return frame_native->damage.n_rectangles;
+}
diff --git a/src/backends/native/meta-frame-native.h b/src/backends/native/meta-frame-native.h
index f86d3b0b0..84bd43b8c 100644
--- a/src/backends/native/meta-frame-native.h
+++ b/src/backends/native/meta-frame-native.h
@@ -17,6 +17,7 @@
 
 #pragma once
 
+#include "backends/native/meta-backend-native-types.h"
 #include "backends/native/meta-kms-types.h"
 #include "clutter/clutter.h"
 #include "core/util-private.h"
@@ -36,3 +37,22 @@ MetaKmsUpdate * meta_frame_native_steal_kms_update (MetaFrameNative *frame_nativ
 
 META_EXPORT_TEST
 gboolean meta_frame_native_has_kms_update (MetaFrameNative *frame_native);
+
+void meta_frame_native_set_buffer (MetaFrameNative *frame_native,
+                                   MetaDrmBuffer   *buffer);
+
+MetaDrmBuffer * meta_frame_native_get_buffer (MetaFrameNative *frame_native);
+
+void meta_frame_native_set_scanout (MetaFrameNative *frame_native,
+                                    CoglScanout     *scanout);
+
+CoglScanout * meta_frame_native_get_scanout (MetaFrameNative *frame_native);
+
+void
+meta_frame_native_set_damage (MetaFrameNative *frame_native,
+                              const int       *rectangles,
+                              int              n_rectangles);
+
+int
+meta_frame_native_get_damage (MetaFrameNative  *frame_native,
+                              int             **rectangles);
diff --git a/src/backends/native/meta-kms-crtc.c b/src/backends/native/meta-kms-crtc.c
index a0872089a..50edfcbe3 100644
--- a/src/backends/native/meta-kms-crtc.c
+++ b/src/backends/native/meta-kms-crtc.c
@@ -28,8 +28,7 @@
 #include "backends/native/meta-kms-update-private.h"
 #include "backends/native/meta-kms-utils.h"
 
-#define DEADLINE_EVASION_US 800
-#define DEADLINE_EVASION_WITH_KMS_TOPIC_US 1000
+#define DEADLINE_EVASION_CONSTANT_US 200
 
 #define MINIMUM_REFRESH_RATE 30.f
 
@@ -50,6 +49,10 @@ struct _MetaKmsCrtc
   MetaKmsCrtcState current_state;
 
   MetaKmsCrtcPropTable prop_table;
+
+  int64_t shortterm_max_dispatch_duration_us;
+  int64_t deadline_evasion_us;
+  int64_t deadline_evasion_update_time_us;
 };
 
 G_DEFINE_TYPE (MetaKmsCrtc, meta_kms_crtc, G_TYPE_OBJECT)
@@ -543,6 +546,33 @@ get_crtc_type_bitmask (MetaKmsCrtc *crtc)
     }
 }
 
+static void
+maybe_update_deadline_evasion (MetaKmsCrtc *crtc,
+                               int64_t      next_presentation_time_us)
+{
+  /* Do not update long-term max if there has been no measurement */
+  if (!crtc->shortterm_max_dispatch_duration_us)
+    return;
+
+  if (next_presentation_time_us - crtc->deadline_evasion_update_time_us <
+      G_USEC_PER_SEC)
+    return;
+
+  if (crtc->deadline_evasion_us > crtc->shortterm_max_dispatch_duration_us)
+    {
+      /* Exponential drop-off toward the clamped short-term max */
+      crtc->deadline_evasion_us -=
+        (crtc->deadline_evasion_us - crtc->shortterm_max_dispatch_duration_us) / 2;
+    }
+  else
+    {
+      crtc->deadline_evasion_us = crtc->shortterm_max_dispatch_duration_us;
+    }
+
+  crtc->shortterm_max_dispatch_duration_us = 0;
+  crtc->deadline_evasion_update_time_us = next_presentation_time_us;
+}
+
 gboolean
 meta_kms_crtc_determine_deadline (MetaKmsCrtc  *crtc,
                                   int64_t      *out_next_deadline_us,
@@ -610,10 +640,8 @@ meta_kms_crtc_determine_deadline (MetaKmsCrtc  *crtc,
        *
        */
 
-      if (meta_is_topic_enabled (META_DEBUG_KMS))
-        deadline_evasion_us = DEADLINE_EVASION_WITH_KMS_TOPIC_US;
-      else
-        deadline_evasion_us = DEADLINE_EVASION_US;
+      deadline_evasion_us = meta_kms_crtc_get_deadline_evasion (crtc);
+      maybe_update_deadline_evasion (crtc, next_presentation_us);
 
       vblank_duration_us = meta_calculate_drm_mode_vblank_duration_us (drm_mode);
       next_deadline_us = next_presentation_us - (vblank_duration_us +
@@ -625,3 +653,33 @@ meta_kms_crtc_determine_deadline (MetaKmsCrtc  *crtc,
 
   return TRUE;
 }
+
+void
+meta_kms_crtc_update_shortterm_max_dispatch_duration (MetaKmsCrtc *crtc,
+                                                      int64_t      duration_us)
+{
+  int64_t refresh_interval_us;
+
+  if (duration_us <= crtc->shortterm_max_dispatch_duration_us)
+    return;
+
+  refresh_interval_us =
+    (int64_t) (0.5 + G_USEC_PER_SEC /
+               meta_calculate_drm_mode_refresh_rate (&crtc->current_state.drm_mode));
+
+  crtc->shortterm_max_dispatch_duration_us = MIN (duration_us, refresh_interval_us);
+}
+
+int64_t
+meta_kms_crtc_get_deadline_evasion (MetaKmsCrtc *crtc)
+{
+  int64_t deadline_evasion_us;
+
+  deadline_evasion_us =
+    MAX (crtc->shortterm_max_dispatch_duration_us, crtc->deadline_evasion_us);
+
+  if (!deadline_evasion_us)
+    return 0;
+
+  return deadline_evasion_us + DEADLINE_EVASION_CONSTANT_US;
+}
diff --git a/src/backends/native/meta-kms-crtc.h b/src/backends/native/meta-kms-crtc.h
index 580ee9a89..b293f8e7c 100644
--- a/src/backends/native/meta-kms-crtc.h
+++ b/src/backends/native/meta-kms-crtc.h
@@ -65,3 +65,8 @@ int meta_kms_crtc_get_idx (MetaKmsCrtc *crtc);
 
 META_EXPORT_TEST
 gboolean meta_kms_crtc_is_active (MetaKmsCrtc *crtc);
+
+void meta_kms_crtc_update_shortterm_max_dispatch_duration (MetaKmsCrtc *crtc,
+                                                           int64_t      duration_us);
+
+int64_t meta_kms_crtc_get_deadline_evasion (MetaKmsCrtc *crtc);
diff --git a/src/backends/native/meta-kms-impl-device-atomic.c b/src/backends/native/meta-kms-impl-device-atomic.c
index 7812ec042..7054186c2 100644
--- a/src/backends/native/meta-kms-impl-device-atomic.c
+++ b/src/backends/native/meta-kms-impl-device-atomic.c
@@ -643,7 +643,7 @@ process_plane_assignment (MetaKmsImplDevice  *impl_device,
             return FALSE;
         }
 
-      if (plane_assignment->flags & META_KMS_ASSIGN_PLANE_FLAG_DIRECT_SCANOUT)
+      if (plane_assignment->flags & META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC)
         {
           int signaled_sync_file;
 
@@ -1387,6 +1387,7 @@ is_atomic_allowed (const char *driver_name)
 {
   const char *atomic_driver_deny_list[] = {
     "xlnx",
+    "tegra",
     NULL,
   };
 
diff --git a/src/backends/native/meta-kms-impl-device.c b/src/backends/native/meta-kms-impl-device.c
index e48cffc4f..a0de4158a 100644
--- a/src/backends/native/meta-kms-impl-device.c
+++ b/src/backends/native/meta-kms-impl-device.c
@@ -39,6 +39,7 @@
 #include "backends/native/meta-kms-plane-private.h"
 #include "backends/native/meta-kms-plane.h"
 #include "backends/native/meta-kms-private.h"
+#include "backends/native/meta-kms-utils.h"
 #include "backends/native/meta-thread-private.h"
 
 #include "meta-default-modes.h"
@@ -71,9 +72,17 @@ typedef struct _CrtcDeadline
     GSource *source;
     gboolean armed;
     gboolean is_deadline_page_flip;
+    int64_t expected_deadline_time_us;
     int64_t expected_presentation_time_us;
     gboolean has_expected_presentation_time;
   } deadline;
+
+  struct {
+    MetaKmsUpdate *kms_update;
+    MetaKmsUpdateFlag flags;
+    MetaKmsCrtc *latch_crtc;
+    GSource *source;
+  } submitted_update;
 } CrtcFrame;
 
 typedef enum _MetaDeadlineTimerState
@@ -1167,6 +1176,7 @@ arm_crtc_frame_deadline_timer (CrtcFrame *crtc_frame,
   timerfd_settime (crtc_frame->deadline.timer_fd,
                    TFD_TIMER_ABSTIME, &its, NULL);
 
+  crtc_frame->deadline.expected_deadline_time_us = next_deadline_us;
   crtc_frame->deadline.expected_presentation_time_us = next_presentation_us;
   crtc_frame->deadline.has_expected_presentation_time = next_presentation_us != 0;
   crtc_frame->deadline.armed = TRUE;
@@ -1199,7 +1209,7 @@ crtc_page_flip_feedback_flipped (MetaKmsCrtc  *crtc,
   CrtcFrame *crtc_frame = user_data;
 
   if (crtc_frame->deadline.is_deadline_page_flip &&
-      meta_is_topic_enabled (META_DEBUG_KMS))
+      meta_is_topic_enabled (META_DEBUG_KMS_DEADLINE))
     {
       struct timeval page_flip_timeval;
       int64_t presentation_time_us;
@@ -1212,7 +1222,7 @@ crtc_page_flip_feedback_flipped (MetaKmsCrtc  *crtc,
 
       if (crtc_frame->deadline.has_expected_presentation_time)
         {
-          meta_topic (META_DEBUG_KMS,
+          meta_topic (META_DEBUG_KMS_DEADLINE,
                       "Deadline page flip presentation time: %" G_GINT64_FORMAT " us, "
                       "expected %" G_GINT64_FORMAT " us "
                       "(diff: %" G_GINT64_FORMAT ")",
@@ -1223,7 +1233,7 @@ crtc_page_flip_feedback_flipped (MetaKmsCrtc  *crtc,
         }
       else
         {
-          meta_topic (META_DEBUG_KMS,
+          meta_topic (META_DEBUG_KMS_DEADLINE,
                       "Deadline page flip presentation time: %" G_GINT64_FORMAT " us",
                       presentation_time_us);
         }
@@ -1392,11 +1402,16 @@ crtc_frame_deadline_dispatch (MetaThreadImpl  *thread_impl,
                               GError         **error)
 {
   CrtcFrame *crtc_frame = user_data;
-  MetaKmsDevice *device = meta_kms_crtc_get_device (crtc_frame->crtc);
+  MetaKmsCrtc *crtc = crtc_frame->crtc;
+  MetaKmsDevice *device = meta_kms_crtc_get_device (crtc);
   MetaKmsImplDevice *impl_device = meta_kms_device_get_impl_device (device);
   g_autoptr (MetaKmsFeedback) feedback = NULL;
   uint64_t timer_value;
   ssize_t ret;
+  int64_t dispatch_time_us = 0, update_done_time_us, interval_us;
+
+  if (meta_is_topic_enabled (META_DEBUG_KMS_DEADLINE))
+    dispatch_time_us = g_get_monotonic_time ();
 
   ret = read (crtc_frame->deadline.timer_fd,
               &timer_value,
@@ -1418,6 +1433,36 @@ crtc_frame_deadline_dispatch (MetaThreadImpl  *thread_impl,
                          crtc_frame->crtc,
                          g_steal_pointer (&crtc_frame->pending_update),
                          META_KMS_UPDATE_FLAG_NONE);
+
+  update_done_time_us = g_get_monotonic_time ();
+  /* Calculate how long after the planned start of deadline dispatch it finished */
+  interval_us = update_done_time_us - crtc_frame->deadline.expected_deadline_time_us;
+
+  if (meta_is_topic_enabled (META_DEBUG_KMS_DEADLINE))
+    {
+      int64_t deadline_evasion_us, lateness_us, duration_us, vblank_delta_us;
+
+      deadline_evasion_us = meta_kms_crtc_get_deadline_evasion (crtc);
+      lateness_us = dispatch_time_us -
+                    crtc_frame->deadline.expected_deadline_time_us;
+      duration_us = update_done_time_us - dispatch_time_us;
+      vblank_delta_us = deadline_evasion_us - lateness_us - duration_us;
+
+      meta_topic (META_DEBUG_KMS_DEADLINE,
+                  "Deadline evasion %3"G_GINT64_FORMAT "µs, "
+                  "dispatch started %3"G_GINT64_FORMAT "µs %s and "
+                  "completed %3"G_GINT64_FORMAT "µs after that, "
+                  "%3"G_GINT64_FORMAT "µs %s start of vblank.",
+                  deadline_evasion_us,
+                  ABS (lateness_us),
+                  lateness_us >= 0 ? "late" : "early",
+                  duration_us,
+                  ABS (vblank_delta_us),
+                  vblank_delta_us >= 0 ? "before" : "after");
+    }
+
+  meta_kms_crtc_update_shortterm_max_dispatch_duration (crtc, interval_us);
+
   if (meta_kms_feedback_did_pass (feedback))
     crtc_frame->deadline.is_deadline_page_flip = TRUE;
   disarm_crtc_frame_deadline_timer (crtc_frame);
@@ -1431,6 +1476,8 @@ crtc_frame_free (CrtcFrame *crtc_frame)
   g_clear_fd (&crtc_frame->deadline.timer_fd, NULL);
   g_clear_pointer (&crtc_frame->deadline.source, g_source_destroy);
   g_clear_pointer (&crtc_frame->pending_update, meta_kms_update_free);
+  g_clear_pointer (&crtc_frame->submitted_update.kms_update, meta_kms_update_free);
+  g_clear_pointer (&crtc_frame->submitted_update.source, g_source_destroy);
   g_free (crtc_frame);
 }
 
@@ -1539,6 +1586,79 @@ queue_update (MetaKmsImplDevice *impl_device,
     }
 }
 
+static gpointer
+meta_kms_impl_device_update_ready (MetaThreadImpl  *impl,
+                                   gpointer         user_data,
+                                   GError         **error)
+{
+  CrtcFrame *crtc_frame = user_data;
+  MetaKmsDevice *device = meta_kms_crtc_get_device (crtc_frame->crtc);
+  MetaKmsImplDevice *impl_device = meta_kms_device_get_impl_device (device);
+  MetaKmsImplDevicePrivate *priv =
+    meta_kms_impl_device_get_instance_private (impl_device);
+  MetaKmsUpdate *update;
+  MetaKmsCrtc *latch_crtc;
+  MetaKmsFeedback *feedback;
+
+  meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
+
+  g_clear_pointer (&crtc_frame->submitted_update.source, g_source_destroy);
+
+  update = g_steal_pointer (&crtc_frame->submitted_update.kms_update);
+  meta_kms_update_realize (update, impl_device);
+
+  latch_crtc = g_steal_pointer (&crtc_frame->submitted_update.latch_crtc);
+
+  if (crtc_frame->pending_page_flip &&
+      !meta_kms_update_get_mode_sets (update))
+    {
+      g_assert (latch_crtc);
+
+      meta_topic (META_DEBUG_KMS,
+                  "Queuing update on CRTC %u (%s): pending page flip",
+                  meta_kms_crtc_get_id (latch_crtc),
+                  priv->path);
+
+      queue_update (impl_device, crtc_frame, update);
+      return GINT_TO_POINTER (TRUE);
+    }
+
+  if (crtc_frame->pending_update)
+    {
+      meta_kms_update_merge_from (crtc_frame->pending_update, update);
+      meta_kms_update_free (update);
+      update = g_steal_pointer (&crtc_frame->pending_update);
+      disarm_crtc_frame_deadline_timer (crtc_frame);
+    }
+
+  meta_kms_device_handle_flush (priv->device, latch_crtc);
+
+  feedback = do_process (impl_device, latch_crtc, update, crtc_frame->submitted_update.flags);
+
+  if (meta_kms_feedback_did_pass (feedback) &&
+      crtc_frame->deadline.armed)
+    disarm_crtc_frame_deadline_timer (crtc_frame);
+
+  meta_kms_feedback_unref (feedback);
+
+  return GINT_TO_POINTER (TRUE);
+}
+
+static gboolean
+is_fd_readable (int fd)
+{
+  GPollFD poll_fd;
+
+  poll_fd.fd = fd;
+  poll_fd.events = G_IO_IN;
+  poll_fd.revents = 0;
+
+  if (!g_poll (&poll_fd, 1, 0))
+    return FALSE;
+
+  return (poll_fd.revents & (G_IO_IN | G_IO_NVAL)) != 0;
+}
+
 void
 meta_kms_impl_device_handle_update (MetaKmsImplDevice *impl_device,
                                     MetaKmsUpdate     *update,
@@ -1546,10 +1666,15 @@ meta_kms_impl_device_handle_update (MetaKmsImplDevice *impl_device,
 {
   MetaKmsImplDevicePrivate *priv =
     meta_kms_impl_device_get_instance_private (impl_device);
+  MetaKmsImpl *kms_impl = meta_kms_impl_device_get_impl (impl_device);
+  MetaThreadImpl *thread_impl = META_THREAD_IMPL (kms_impl);
   g_autoptr (GError) error = NULL;
   MetaKmsCrtc *latch_crtc;
   CrtcFrame *crtc_frame;
   MetaKmsFeedback *feedback;
+  g_autoptr (GSource) source = NULL;
+  g_autofree char *name = NULL;
+  int sync_fd = -1;
 
   meta_assert_in_kms_impl (meta_kms_impl_get_kms (priv->impl));
 
@@ -1570,38 +1695,58 @@ meta_kms_impl_device_handle_update (MetaKmsImplDevice *impl_device,
   if (!ensure_device_file (impl_device, &error))
     goto err;
 
-  meta_kms_update_realize (update, impl_device);
-
   crtc_frame = ensure_crtc_frame (impl_device, latch_crtc);
 
+  if (crtc_frame->submitted_update.kms_update)
+    {
+      g_set_error (&error, G_IO_ERROR, G_IO_ERROR_PENDING,
+                   "Previously-submitted update wasn't ready yet");
+      goto err;
+    }
+
   crtc_frame->await_flush = FALSE;
+  crtc_frame->submitted_update.kms_update = update;
+  crtc_frame->submitted_update.flags = flags;
+  crtc_frame->submitted_update.latch_crtc = latch_crtc;
 
-  if (crtc_frame->pending_page_flip &&
-      !meta_kms_update_get_mode_sets (update))
+  if (is_using_deadline_timer (impl_device))
+    sync_fd = meta_kms_update_get_sync_fd (update);
+
+  if (sync_fd >= 0)
     {
-      g_assert (latch_crtc);
+      GList *l;
 
-      meta_topic (META_DEBUG_KMS,
-                  "Queuing update on CRTC %u (%s): pending page flip",
-                  meta_kms_crtc_get_id (latch_crtc),
-                  priv->path);
+      for (l = meta_kms_update_get_plane_assignments (update); l; l = l->next)
+        {
+          MetaKmsPlaneAssignment *assignment = l->data;
 
-      queue_update (impl_device, crtc_frame, update);
-      return;
+          assignment->flags |= META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC;
+        }
     }
 
-  if (crtc_frame->pending_update)
+  if (sync_fd < 0 ||
+      is_fd_readable (sync_fd))
     {
-      meta_kms_update_merge_from (crtc_frame->pending_update, update);
-      meta_kms_update_free (update);
-      update = g_steal_pointer (&crtc_frame->pending_update);
-      disarm_crtc_frame_deadline_timer (crtc_frame);
+      meta_kms_impl_device_update_ready (thread_impl,
+                                         crtc_frame,
+                                         NULL);
+      return;
     }
 
-  meta_kms_device_handle_flush (priv->device, latch_crtc);
+  source = meta_thread_impl_register_fd (thread_impl,
+                                         sync_fd,
+                                         meta_kms_impl_device_update_ready,
+                                         crtc_frame);
 
-  feedback = do_process (impl_device, latch_crtc, update, flags);
-  meta_kms_feedback_unref (feedback);
+  name = g_strdup_printf ("[mutter] KMS update sync_fd (crtc: %u, %s)",
+                          meta_kms_crtc_get_id (latch_crtc),
+                          priv->path);
+  g_source_set_name (source, name);
+  g_source_set_priority (source, G_PRIORITY_HIGH + 1);
+  g_source_set_can_recurse (source, FALSE);
+  g_source_set_ready_time (source, -1);
+
+  crtc_frame->submitted_update.source = source;
   return;
 
 err:
diff --git a/src/backends/native/meta-kms-update.c b/src/backends/native/meta-kms-update.c
index fc605bec1..a5da81f0c 100644
--- a/src/backends/native/meta-kms-update.c
+++ b/src/backends/native/meta-kms-update.c
@@ -20,6 +20,8 @@
 #include "backends/native/meta-kms-update.h"
 #include "backends/native/meta-kms-update-private.h"
 
+#include <glib/gstdio.h>
+
 #include "backends/meta-display-config-shared.h"
 #include "backends/native/meta-kms-connector.h"
 #include "backends/native/meta-kms-crtc.h"
@@ -51,6 +53,8 @@ struct _MetaKmsUpdate
   gboolean needs_modeset;
 
   MetaKmsImplDevice *impl_device;
+
+  int sync_fd;
 };
 
 void
@@ -1136,6 +1140,8 @@ meta_kms_update_merge_from (MetaKmsUpdate *update,
   merge_custom_page_flip_from (update, other_update);
   merge_page_flip_listeners_from (update, other_update);
   merge_result_listeners_from (update, other_update);
+
+  meta_kms_update_set_sync_fd (update, g_steal_fd (&other_update->sync_fd));
 }
 
 gboolean
@@ -1152,6 +1158,7 @@ meta_kms_update_new (MetaKmsDevice *device)
   update = g_new0 (MetaKmsUpdate, 1);
   update->device = device;
   update->is_latchable = TRUE;
+  update->sync_fd = -1;
 
   return update;
 }
@@ -1175,6 +1182,7 @@ meta_kms_update_free (MetaKmsUpdate *update)
   g_list_free_full (update->crtc_color_updates,
                     (GDestroyNotify) meta_kms_crtc_color_updates_free);
   g_clear_pointer (&update->custom_page_flip, meta_kms_custom_page_flip_free);
+  g_clear_fd (&update->sync_fd, NULL);
 
   g_free (update);
 }
@@ -1200,6 +1208,23 @@ meta_kms_update_get_latch_crtc (MetaKmsUpdate *update)
   return update->latch_crtc;
 }
 
+int
+meta_kms_update_get_sync_fd (MetaKmsUpdate *update)
+{
+  return update->sync_fd;
+}
+
+void
+meta_kms_update_set_sync_fd (MetaKmsUpdate *update,
+                             int            sync_fd)
+{
+  if (update->sync_fd == sync_fd)
+    return;
+
+  g_clear_fd (&update->sync_fd, NULL);
+  update->sync_fd = sync_fd;
+}
+
 gboolean
 meta_kms_update_is_empty (MetaKmsUpdate *update)
 {
diff --git a/src/backends/native/meta-kms-update.h b/src/backends/native/meta-kms-update.h
index 1951c80f6..ebb50cbaa 100644
--- a/src/backends/native/meta-kms-update.h
+++ b/src/backends/native/meta-kms-update.h
@@ -39,7 +39,7 @@ typedef enum _MetaKmsAssignPlaneFlag
   META_KMS_ASSIGN_PLANE_FLAG_NONE = 0,
   META_KMS_ASSIGN_PLANE_FLAG_FB_UNCHANGED = 1 << 0,
   META_KMS_ASSIGN_PLANE_FLAG_ALLOW_FAIL = 1 << 1,
-  META_KMS_ASSIGN_PLANE_FLAG_DIRECT_SCANOUT = 1 << 2,
+  META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC = 1 << 2,
 } MetaKmsAssignPlaneFlag;
 
 struct _MetaKmsPageFlipListenerVtable
@@ -157,6 +157,13 @@ void meta_kms_update_set_crtc_gamma (MetaKmsUpdate      *update,
                                      MetaKmsCrtc        *crtc,
                                      const MetaGammaLut *gamma);
 
+int
+meta_kms_update_get_sync_fd (MetaKmsUpdate *update);
+
+void
+meta_kms_update_set_sync_fd (MetaKmsUpdate *update,
+                             int            sync_fd);
+
 void meta_kms_plane_assignment_set_fb_damage (MetaKmsPlaneAssignment *plane_assignment,
                                               const int              *rectangles,
                                               int                     n_rectangles);
diff --git a/src/backends/native/meta-kms.c b/src/backends/native/meta-kms.c
index d989337a1..4253a2adc 100644
--- a/src/backends/native/meta-kms.c
+++ b/src/backends/native/meta-kms.c
@@ -63,6 +63,8 @@ struct _MetaKms
   int kernel_thread_inhibit_count;
 
   MetaKmsCursorManager *cursor_manager;
+
+  gboolean shutting_down;
 };
 
 G_DEFINE_TYPE (MetaKms, meta_kms, META_TYPE_THREAD)
@@ -339,6 +341,12 @@ meta_kms_create_device (MetaKms            *kms,
   return device;
 }
 
+gboolean
+meta_kms_is_shutting_down (MetaKms *kms)
+{
+  return kms->shutting_down;
+}
+
 static gpointer
 prepare_shutdown_in_impl (MetaThreadImpl  *thread_impl,
                           gpointer         user_data,
@@ -354,6 +362,7 @@ static void
 on_prepare_shutdown (MetaBackend *backend,
                      MetaKms     *kms)
 {
+  kms->shutting_down = TRUE;
   meta_kms_run_impl_task_sync (kms, prepare_shutdown_in_impl, NULL, NULL);
   meta_thread_flush_callbacks (META_THREAD (kms));
 
diff --git a/src/backends/native/meta-kms.h b/src/backends/native/meta-kms.h
index 057c7a234..0d6986529 100644
--- a/src/backends/native/meta-kms.h
+++ b/src/backends/native/meta-kms.h
@@ -60,6 +60,8 @@ MetaKmsDevice * meta_kms_create_device (MetaKms            *kms,
                                         MetaKmsDeviceFlag   flags,
                                         GError            **error);
 
+gboolean meta_kms_is_shutting_down (MetaKms *kms);
+
 MetaKms * meta_kms_new (MetaBackend   *backend,
                         MetaKmsFlags   flags,
                         GError       **error);
diff --git a/src/backends/native/meta-onscreen-native.c b/src/backends/native/meta-onscreen-native.c
index 34709dccf..c9162d31b 100644
--- a/src/backends/native/meta-onscreen-native.c
+++ b/src/backends/native/meta-onscreen-native.c
@@ -29,6 +29,7 @@
 
 #include "backends/native/meta-onscreen-native.h"
 
+#include <glib/gstdio.h>
 #include <drm_fourcc.h>
 
 #include "backends/meta-egl-ext.h"
@@ -76,7 +77,7 @@ typedef struct _MetaOnscreenNativeSecondaryGpuState
 
   struct {
     MetaDrmBufferDumb *current_dumb_fb;
-    MetaDrmBufferDumb *dumb_fbs[2];
+    MetaDrmBufferDumb *dumb_fbs[3];
   } cpu;
 
   gboolean noted_primary_gpu_copy_ok;
@@ -102,12 +103,13 @@ struct _MetaOnscreenNative
 
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
 
+  ClutterFrame *presented_frame;
+  ClutterFrame *posted_frame;
+  ClutterFrame *stalled_frame;
+  ClutterFrame *next_frame;
+
   struct {
     struct gbm_surface *surface;
-    MetaDrmBuffer *current_fb;
-    MetaDrmBuffer *next_fb;
-    CoglScanout *current_scanout;
-    CoglScanout *next_scanout;
   } gbm;
 
 #ifdef HAVE_EGL_DEVICE
@@ -118,6 +120,9 @@ struct _MetaOnscreenNative
   } egl;
 #endif
 
+  gboolean needs_flush;
+  unsigned int swaps_pending;
+
   gboolean frame_sync_requested;
   gboolean frame_sync_enabled;
 
@@ -139,44 +144,37 @@ G_DEFINE_TYPE (MetaOnscreenNative, meta_onscreen_native,
 
 static GQuark blit_source_quark = 0;
 
+static void
+try_post_latest_swap (CoglOnscreen *onscreen);
+
+static void
+post_finish_frame (MetaOnscreenNative *onscreen_native,
+                   MetaKmsUpdate      *kms_update);
+
 static gboolean
 init_secondary_gpu_state (MetaRendererNative  *renderer_native,
                           CoglOnscreen        *onscreen,
                           GError             **error);
 
-static void
-free_current_bo (CoglOnscreen *onscreen)
-{
-  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-
-  g_clear_object (&onscreen_native->gbm.current_fb);
-  g_clear_object (&onscreen_native->gbm.current_scanout);
-}
-
 static void
 meta_onscreen_native_swap_drm_fb (CoglOnscreen *onscreen)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
-  if (!onscreen_native->gbm.next_fb)
+  if (!onscreen_native->posted_frame)
     return;
 
-  free_current_bo (onscreen);
-
-  g_set_object (&onscreen_native->gbm.current_fb, onscreen_native->gbm.next_fb);
-  g_clear_object (&onscreen_native->gbm.next_fb);
-  g_set_object (&onscreen_native->gbm.current_scanout,
-                onscreen_native->gbm.next_scanout);
-  g_clear_object (&onscreen_native->gbm.next_scanout);
+  g_clear_pointer (&onscreen_native->presented_frame, clutter_frame_unref);
+  onscreen_native->presented_frame =
+    g_steal_pointer (&onscreen_native->posted_frame);
 }
 
 static void
-meta_onscreen_native_clear_next_fb (CoglOnscreen *onscreen)
+meta_onscreen_native_clear_posted_fb (CoglOnscreen *onscreen)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
-  g_clear_object (&onscreen_native->gbm.next_fb);
-  g_clear_object (&onscreen_native->gbm.next_scanout);
+  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
 }
 
 static void
@@ -214,7 +212,7 @@ meta_onscreen_native_notify_frame_complete (CoglOnscreen *onscreen)
 
   info = cogl_onscreen_pop_head_frame_info (onscreen);
 
-  g_assert (!cogl_onscreen_peek_head_frame_info (onscreen));
+  g_return_if_fail (info);
 
   _cogl_onscreen_notify_frame_sync (onscreen, info);
   _cogl_onscreen_notify_complete (onscreen, info);
@@ -256,6 +254,7 @@ notify_view_crtc_presented (MetaRendererView *view,
 
   meta_onscreen_native_notify_frame_complete (onscreen);
   meta_onscreen_native_swap_drm_fb (onscreen);
+  try_post_latest_swap (onscreen);
 }
 
 static void
@@ -305,15 +304,13 @@ page_flip_feedback_ready (MetaKmsCrtc *kms_crtc,
   CoglFramebuffer *framebuffer =
     clutter_stage_view_get_onscreen (CLUTTER_STAGE_VIEW (view));
   CoglOnscreen *onscreen = COGL_ONSCREEN (framebuffer);
-  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   CoglFrameInfo *frame_info;
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
-  g_warn_if_fail (!onscreen_native->gbm.next_fb);
-
   meta_onscreen_native_notify_frame_complete (onscreen);
+  try_post_latest_swap (onscreen);
 }
 
 static void
@@ -379,7 +376,8 @@ page_flip_feedback_discarded (MetaKmsCrtc  *kms_crtc,
     }
 
   meta_onscreen_native_notify_frame_complete (onscreen);
-  meta_onscreen_native_clear_next_fb (onscreen);
+  meta_onscreen_native_clear_posted_fb (onscreen);
+  try_post_latest_swap (onscreen);
 }
 
 static const MetaKmsPageFlipListenerVtable page_flip_listener_vtable = {
@@ -440,18 +438,36 @@ custom_egl_stream_page_flip (gpointer custom_page_flip_data,
 }
 #endif /* HAVE_EGL_DEVICE */
 
-void
-meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen)
+static void
+drop_stalled_swap (CoglOnscreen *onscreen)
 {
   CoglFrameInfo *frame_info;
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
 
-  meta_onscreen_native_swap_drm_fb (onscreen);
+  if (onscreen_native->swaps_pending <= 1)
+    return;
+
+  onscreen_native->swaps_pending--;
+
+  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
 
   frame_info = cogl_onscreen_peek_tail_frame_info (onscreen);
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
   meta_onscreen_native_notify_frame_complete (onscreen);
 }
 
+void
+meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen)
+{
+  drop_stalled_swap (onscreen);
+
+  /* If the monitor just woke up and the shell is fully idle (has nothing
+   * more to swap) then we just woke to an indefinitely black screen. Let's
+   * fix that using the last swap (which is never classified as "stalled").
+   */
+  try_post_latest_swap (onscreen);
+}
+
 static void
 apply_transform (MetaCrtcKms            *crtc_kms,
                  MetaKmsPlaneAssignment *kms_plane_assignment,
@@ -528,12 +544,15 @@ meta_onscreen_native_flip_crtc (CoglOnscreen           *onscreen,
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
+  g_autoptr (ClutterFrame) frame = NULL;
+  MetaFrameNative *frame_native;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   MetaCrtcKms *crtc_kms = META_CRTC_KMS (crtc);
   MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
   MetaRendererNativeGpuData *renderer_gpu_data;
   MetaGpuKms *gpu_kms;
   MetaDrmBuffer *buffer;
+  CoglScanout *scanout;
   MetaKmsPlaneAssignment *plane_assignment;
   graphene_rect_t src_rect;
   MtkRectangle dst_rect;
@@ -541,6 +560,9 @@ meta_onscreen_native_flip_crtc (CoglOnscreen           *onscreen,
   COGL_TRACE_BEGIN_SCOPED (MetaOnscreenNativeFlipCrtcs,
                            "Meta::OnscreenNative::flip_crtc()");
 
+  frame = g_steal_pointer (&onscreen_native->next_frame);
+  g_return_if_fail (frame);
+
   gpu_kms = META_GPU_KMS (meta_crtc_get_gpu (crtc));
 
   g_assert (meta_gpu_kms_is_crtc_active (gpu_kms, crtc));
@@ -550,14 +572,14 @@ meta_onscreen_native_flip_crtc (CoglOnscreen           *onscreen,
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
-      buffer = onscreen_native->gbm.next_fb;
+      frame_native = meta_frame_native_from_frame (frame);
+      buffer = meta_frame_native_get_buffer (frame_native);
+      scanout = meta_frame_native_get_scanout (frame_native);
 
-      if (onscreen_native->gbm.next_scanout)
+      if (scanout)
         {
-          cogl_scanout_get_src_rect (onscreen_native->gbm.next_scanout,
-                                     &src_rect);
-          cogl_scanout_get_dst_rect (onscreen_native->gbm.next_scanout,
-                                     &dst_rect);
+          cogl_scanout_get_src_rect (scanout, &src_rect);
+          cogl_scanout_get_dst_rect (scanout, &dst_rect);
         }
       else
         {
@@ -601,6 +623,10 @@ meta_onscreen_native_flip_crtc (CoglOnscreen           *onscreen,
 #endif
     }
 
+  g_warn_if_fail (!onscreen_native->posted_frame);
+  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
+  onscreen_native->posted_frame = g_steal_pointer (&frame);
+
   meta_kms_update_add_page_flip_listener (kms_update,
                                           kms_crtc,
                                           &page_flip_listener_vtable,
@@ -849,29 +875,63 @@ import_shared_framebuffer (CoglOnscreen                        *onscreen,
 }
 
 static MetaDrmBuffer *
-copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
-                             MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state,
-                             MetaRendererNativeGpuData           *renderer_gpu_data,
-                             gboolean                            *egl_context_changed,
-                             MetaDrmBuffer                       *primary_gpu_fb)
+copy_shared_framebuffer_gpu (CoglOnscreen                         *onscreen,
+                             MetaOnscreenNativeSecondaryGpuState  *secondary_gpu_state,
+                             MetaRendererNativeGpuData            *renderer_gpu_data,
+                             MetaDrmBuffer                        *primary_gpu_fb,
+                             GError                              **error)
 {
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
   MetaEgl *egl = meta_renderer_native_get_egl (renderer_native);
   MetaGles3 *gles3 = meta_renderer_native_get_gles3 (renderer_native);
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
+  CoglRendererEGL *cogl_renderer_egl = cogl_context->display->renderer->winsys;
   MetaRenderDevice *render_device;
-  EGLDisplay egl_display;
-  GError *error = NULL;
+  EGLDisplay egl_display = NULL;
   gboolean use_modifiers;
   MetaDeviceFile *device_file;
   MetaDrmBufferFlags flags;
-  MetaDrmBufferGbm *buffer_gbm;
+  MetaDrmBufferGbm *buffer_gbm = NULL;
   struct gbm_bo *bo;
+  EGLSync primary_gpu_egl_sync = EGL_NO_SYNC;
+  EGLSync secondary_gpu_egl_sync = EGL_NO_SYNC;
+  g_autofd int primary_gpu_sync_fence = EGL_NO_NATIVE_FENCE_FD_ANDROID;
 
   COGL_TRACE_BEGIN_SCOPED (CopySharedFramebufferSecondaryGpu,
                            "copy_shared_framebuffer_gpu()");
 
   if (renderer_gpu_data->secondary.needs_explicit_sync)
-    cogl_framebuffer_finish (COGL_FRAMEBUFFER (onscreen));
+    {
+      if (!meta_egl_create_sync (egl,
+                                cogl_renderer_egl->edpy,
+                                EGL_SYNC_NATIVE_FENCE_ANDROID,
+                                NULL,
+                                &primary_gpu_egl_sync,
+                                error))
+       {
+         g_prefix_error (error, "Failed to create EGLSync on primary GPU: ");
+         return NULL;
+       }
+
+      // According to the EGL_KHR_fence_sync specification we must ensure
+      // the fence command is flushed in this context to be able to await it
+      // in another (secondary GPU context) or we risk waiting indefinitely.
+      cogl_framebuffer_flush (COGL_FRAMEBUFFER (onscreen));
+
+      primary_gpu_sync_fence =
+        meta_egl_duplicate_native_fence_fd (egl,
+                                            cogl_renderer_egl->edpy,
+                                            primary_gpu_egl_sync,
+                                            error);
+
+      if (primary_gpu_sync_fence == EGL_NO_NATIVE_FENCE_FD_ANDROID)
+        {
+          g_prefix_error (error, "Failed to duplicate EGLSync FD on primary GPU: ");
+          goto done;
+        }
+    }
 
   render_device = renderer_gpu_data->render_device;
   egl_display = meta_render_device_get_egl_display (render_device);
@@ -881,15 +941,45 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
                               secondary_gpu_state->egl_surface,
                               secondary_gpu_state->egl_surface,
                               renderer_gpu_data->secondary.egl_context,
-                              &error))
+                              error))
     {
-      g_warning ("Failed to make current: %s", error->message);
-      g_error_free (error);
-      return NULL;
+      g_prefix_error (error, "Failed to make current: ");
+      goto done;
     }
 
-  *egl_context_changed = TRUE;
+  if (primary_gpu_sync_fence != EGL_NO_NATIVE_FENCE_FD_ANDROID)
+    {
+      EGLAttrib attribs[3];
 
+      attribs[0] = EGL_SYNC_NATIVE_FENCE_FD_ANDROID;
+      attribs[1] = primary_gpu_sync_fence;
+      attribs[2] = EGL_NONE;
+
+      if (!meta_egl_create_sync (egl,
+                                egl_display,
+                                EGL_SYNC_NATIVE_FENCE_ANDROID,
+                                attribs,
+                                &secondary_gpu_egl_sync,
+                                error))
+        {
+          g_prefix_error (error, "Failed to create EGLSync on secondary GPU: ");
+          goto done;
+        }
+
+      // eglCreateSync takes ownership of an existing fd that is passed, so
+      // don't try to clean it up twice.
+      primary_gpu_sync_fence = EGL_NO_NATIVE_FENCE_FD_ANDROID;
+
+      if (!meta_egl_wait_sync (egl,
+                               egl_display,
+                               secondary_gpu_egl_sync,
+                               0,
+                               error))
+        {
+          g_prefix_error (error, "Failed to wait for EGLSync on secondary GPU: ");
+          goto done;
+        }
+    }
 
   buffer_gbm = META_DRM_BUFFER_GBM (primary_gpu_fb);
   bo = meta_drm_buffer_gbm_get_bo (buffer_gbm);
@@ -899,21 +989,19 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
                                                   renderer_gpu_data->secondary.egl_context,
                                                   secondary_gpu_state->egl_surface,
                                                   bo,
-                                                  &error))
+                                                  error))
     {
-      g_warning ("Failed to blit shared framebuffer: %s", error->message);
-      g_error_free (error);
-      return NULL;
+      g_prefix_error (error, "Failed to blit shared framebuffer: ");
+      goto done;
     }
 
   if (!meta_egl_swap_buffers (egl,
                               egl_display,
                               secondary_gpu_state->egl_surface,
-                              &error))
+                              error))
     {
-      g_warning ("Failed to swap buffers: %s", error->message);
-      g_error_free (error);
-      return NULL;
+      g_prefix_error (error, "Failed to swap buffers: ");
+      goto done;
     }
 
   use_modifiers = meta_renderer_native_use_modifiers (renderer_native);
@@ -927,13 +1015,11 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
     meta_drm_buffer_gbm_new_lock_front (device_file,
                                         secondary_gpu_state->gbm.surface,
                                         flags,
-                                        &error);
+                                        error);
   if (!buffer_gbm)
     {
-      g_warning ("meta_drm_buffer_gbm_new_lock_front failed: %s",
-                 error->message);
-      g_error_free (error);
-      return NULL;
+      g_prefix_error (error, "meta_drm_buffer_gbm_new_lock_front failed: ");
+      goto done;
     }
 
   g_object_set_qdata_full (G_OBJECT (buffer_gbm),
@@ -941,19 +1027,41 @@ copy_shared_framebuffer_gpu (CoglOnscreen                        *onscreen,
                            g_object_ref (primary_gpu_fb),
                            g_object_unref);
 
-  return META_DRM_BUFFER (buffer_gbm);
+done:
+  _cogl_winsys_egl_ensure_current (cogl_display);
+
+  if (primary_gpu_egl_sync != EGL_NO_SYNC &&
+      !meta_egl_destroy_sync (egl,
+                              cogl_renderer_egl->edpy,
+                              primary_gpu_egl_sync,
+                              error))
+    g_prefix_error (error, "Failed to destroy primary GPU EGLSync: ");
+
+  if (secondary_gpu_egl_sync != EGL_NO_SYNC &&
+      !meta_egl_destroy_sync (egl,
+                              egl_display,
+                              secondary_gpu_egl_sync,
+                              error))
+    g_prefix_error (error, "Failed to destroy secondary GPU EGLSync: ");
+
+  return buffer_gbm ? META_DRM_BUFFER (buffer_gbm) : NULL;
 }
 
 static MetaDrmBufferDumb *
 secondary_gpu_get_next_dumb_buffer (MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state)
 {
   MetaDrmBufferDumb *current_dumb_fb;
+  const int n_dumb_fbs = G_N_ELEMENTS (secondary_gpu_state->cpu.dumb_fbs);
+  int i;
 
   current_dumb_fb = secondary_gpu_state->cpu.current_dumb_fb;
-  if (current_dumb_fb == secondary_gpu_state->cpu.dumb_fbs[0])
-    return secondary_gpu_state->cpu.dumb_fbs[1];
-  else
-    return secondary_gpu_state->cpu.dumb_fbs[0];
+  for (i = 0; i < n_dumb_fbs; i++)
+    {
+      if (current_dumb_fb == secondary_gpu_state->cpu.dumb_fbs[i])
+        return secondary_gpu_state->cpu.dumb_fbs[(i + 1) % n_dumb_fbs];
+    }
+
+  return secondary_gpu_state->cpu.dumb_fbs[0];
 }
 
 static MetaDrmBuffer *
@@ -1193,56 +1301,54 @@ update_secondary_gpu_state_pre_swap_buffers (CoglOnscreen *onscreen,
   return copy;
 }
 
-static void
-update_secondary_gpu_state_post_swap_buffers (CoglOnscreen   *onscreen,
-                                              gboolean       *egl_context_changed,
-                                              MetaDrmBuffer  *primary_gpu_fb,
-                                              MetaDrmBuffer **secondary_gpu_fb)
+static MetaDrmBuffer *
+acquire_front_buffer (CoglOnscreen   *onscreen,
+                      MetaDrmBuffer  *primary_gpu_fb,
+                      MetaDrmBuffer  *secondary_gpu_fb,
+                      GError        **error)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaRendererNative *renderer_native = onscreen_native->renderer_native;
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
+  MetaRendererNativeGpuData *renderer_gpu_data;
+  MetaDrmBuffer *imported_fb;
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeGpuStatePostSwapBuffers,
-                           "update_secondary_gpu_state_post_swap_buffers()");
+                           "acquire_front_buffer()");
 
   secondary_gpu_state = onscreen_native->secondary_gpu_state;
-  if (secondary_gpu_state)
-    {
-      MetaRendererNativeGpuData *renderer_gpu_data;
-      g_autoptr (MetaDrmBuffer) next_fb = NULL;
+  if (!secondary_gpu_state)
+    return g_object_ref (primary_gpu_fb);
 
-      renderer_gpu_data =
-        meta_renderer_native_get_gpu_data (renderer_native,
-                                           secondary_gpu_state->gpu_kms);
-      switch (renderer_gpu_data->secondary.copy_mode)
-        {
-        case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
-          next_fb = import_shared_framebuffer (onscreen,
+  renderer_gpu_data =
+    meta_renderer_native_get_gpu_data (renderer_native,
+                                       secondary_gpu_state->gpu_kms);
+  switch (renderer_gpu_data->secondary.copy_mode)
+    {
+    case META_SHARED_FRAMEBUFFER_COPY_MODE_ZERO:
+      imported_fb = import_shared_framebuffer (onscreen,
                                                secondary_gpu_state,
                                                primary_gpu_fb);
-          if (next_fb)
-            break;
-          /* The fallback was prepared in pre_swap_buffers and is currently
-           * in secondary_gpu_fb.
-           */
-          renderer_gpu_data->secondary.copy_mode =
-            META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY;
-          G_GNUC_FALLTHROUGH;
-        case META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY:
-          next_fb = g_object_ref (*secondary_gpu_fb);
-          break;
-        case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
-          next_fb = copy_shared_framebuffer_gpu (onscreen,
-                                                 secondary_gpu_state,
-                                                 renderer_gpu_data,
-                                                 egl_context_changed,
-                                                 primary_gpu_fb);
-          break;
-        }
-
-      g_set_object (secondary_gpu_fb, next_fb);
+      if (imported_fb)
+        return imported_fb;
+      /* The fallback was prepared in pre_swap_buffers and is currently
+       * in secondary_gpu_fb.
+       */
+      renderer_gpu_data->secondary.copy_mode =
+        META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY;
+      G_GNUC_FALLTHROUGH;
+    case META_SHARED_FRAMEBUFFER_COPY_MODE_PRIMARY:
+      return g_object_ref (secondary_gpu_fb);
+    case META_SHARED_FRAMEBUFFER_COPY_MODE_SECONDARY_GPU:
+      return copy_shared_framebuffer_gpu (onscreen,
+                                          secondary_gpu_state,
+                                          renderer_gpu_data,
+                                          primary_gpu_fb,
+                                          error);
     }
+
+  g_assert_not_reached ();
+  return NULL;
 }
 
 static void
@@ -1285,10 +1391,36 @@ swap_buffer_result_feedback (const MetaKmsFeedback *kms_feedback,
     g_warning ("Page flip failed: %s", error->message);
 
   frame_info = cogl_onscreen_peek_head_frame_info (onscreen);
-  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
-  meta_onscreen_native_notify_frame_complete (onscreen);
-  meta_onscreen_native_clear_next_fb (onscreen);
+  /* After resuming from suspend, drop_stalled_swap might have done this
+   * already and emptied the frame_info queue.
+   */
+  if (frame_info)
+    {
+      frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
+      meta_onscreen_native_notify_frame_complete (onscreen);
+    }
+
+  meta_onscreen_native_clear_posted_fb (onscreen);
+}
+
+static void
+assign_next_frame (MetaOnscreenNative *onscreen_native,
+                   ClutterFrame       *frame)
+{
+  CoglOnscreen *onscreen = COGL_ONSCREEN (onscreen_native);
+
+  if (onscreen_native->next_frame != NULL)
+    {
+      g_warn_if_fail (onscreen_native->stalled_frame == NULL);
+      drop_stalled_swap (onscreen);
+      g_warn_if_fail (onscreen_native->stalled_frame == NULL);
+      g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
+      onscreen_native->stalled_frame =
+        g_steal_pointer (&onscreen_native->next_frame);
+    }
+
+  onscreen_native->next_frame = clutter_frame_ref (frame);
 }
 
 static const MetaKmsResultListenerVtable swap_buffer_result_listener_vtable = {
@@ -1304,37 +1436,41 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
 {
   CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
   CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
-  CoglDisplay *cogl_display = cogl_context_get_display (cogl_context);
   CoglRenderer *cogl_renderer = cogl_context->display->renderer;
   CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
   MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
   MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
-  MetaRenderer *renderer = META_RENDERER (renderer_native);
-  MetaBackend *backend = meta_renderer_get_backend (renderer);
-  MetaMonitorManager *monitor_manager =
-    meta_backend_get_monitor_manager (backend);
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
   MetaOnscreenNativeSecondaryGpuState *secondary_gpu_state;
   MetaGpuKms *render_gpu = onscreen_native->render_gpu;
   MetaDeviceFile *render_device_file;
   ClutterFrame *frame = user_data;
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
-  MetaKmsUpdate *kms_update;
   CoglOnscreenClass *parent_class;
   gboolean create_timestamp_query = TRUE;
-  gboolean egl_context_changed = FALSE;
-  MetaPowerSave power_save_mode;
   g_autoptr (GError) error = NULL;
   MetaDrmBufferFlags buffer_flags;
   MetaDrmBufferGbm *buffer_gbm;
   g_autoptr (MetaDrmBuffer) primary_gpu_fb = NULL;
   g_autoptr (MetaDrmBuffer) secondary_gpu_fb = NULL;
-  MetaKmsCrtc *kms_crtc;
-  MetaKmsDevice *kms_device;
+  g_autoptr (MetaDrmBuffer) buffer = NULL;
 
   COGL_TRACE_BEGIN_SCOPED (MetaRendererNativeSwapBuffers,
                            "Meta::OnscreenNative::swap_buffers_with_damage()");
 
+  if (meta_is_topic_enabled (META_DEBUG_KMS))
+    {
+      unsigned int frames_pending =
+        cogl_onscreen_get_pending_frame_count (onscreen);
+
+      meta_topic (META_DEBUG_KMS,
+                  "Swap buffers: %u frames pending (%s-buffering)",
+                  frames_pending,
+                  frames_pending == 1 ? "double" :
+                  frames_pending == 2 ? "triple" :
+                  "?");
+    }
+
   secondary_gpu_fb =
     update_secondary_gpu_state_pre_swap_buffers (onscreen,
                                                  rectangles,
@@ -1384,46 +1520,28 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
           g_warning ("Failed to lock front buffer on %s: %s",
                      meta_device_file_get_path (render_device_file),
                      error->message);
-
-          frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
-          meta_onscreen_native_notify_frame_complete (onscreen);
-          return;
+          goto swap_failed;
         }
 
       primary_gpu_fb = META_DRM_BUFFER (g_steal_pointer (&buffer_gbm));
-      break;
-    case META_RENDERER_NATIVE_MODE_SURFACELESS:
-      g_assert_not_reached ();
-      break;
-#ifdef HAVE_EGL_DEVICE
-    case META_RENDERER_NATIVE_MODE_EGL_DEVICE:
-      break;
-#endif
-    }
+      buffer = acquire_front_buffer (onscreen,
+                                     primary_gpu_fb,
+                                     secondary_gpu_fb,
+                                     &error);
+      if (buffer == NULL)
+        {
+          g_warning ("Failed to acquire front buffer: %s", error->message);
+          goto swap_failed;
+        }
 
-  update_secondary_gpu_state_post_swap_buffers (onscreen,
-                                                &egl_context_changed,
-                                                primary_gpu_fb,
-                                                &secondary_gpu_fb);
+      meta_frame_native_set_buffer (frame_native, buffer);
 
-  switch (renderer_gpu_data->mode)
-    {
-    case META_RENDERER_NATIVE_MODE_GBM:
-      g_warn_if_fail (onscreen_native->gbm.next_fb == NULL);
-      if (onscreen_native->secondary_gpu_state)
-        g_set_object (&onscreen_native->gbm.next_fb, secondary_gpu_fb);
-      else
-        g_set_object (&onscreen_native->gbm.next_fb, primary_gpu_fb);
-
-      if (!meta_drm_buffer_ensure_fb_id (onscreen_native->gbm.next_fb, &error))
+      if (!meta_drm_buffer_ensure_fb_id (buffer, &error))
         {
           g_warning ("Failed to ensure KMS FB ID on %s: %s",
                      meta_device_file_get_path (render_device_file),
                      error->message);
-
-          frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
-          meta_onscreen_native_notify_frame_complete (onscreen);
-          return;
+          goto swap_failed;
         }
       break;
     case META_RENDERER_NATIVE_MODE_SURFACELESS:
@@ -1434,21 +1552,86 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
 #endif
     }
 
-  /*
-   * If we changed EGL context, cogl will have the wrong idea about what is
-   * current, making it fail to set it when it needs to. Avoid that by making
-   * EGL_NO_CONTEXT current now, making cogl eventually set the correct
-   * context.
-   */
-  if (egl_context_changed)
-    _cogl_winsys_egl_ensure_current (cogl_display);
+  assign_next_frame (onscreen_native, frame);
 
-  kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (onscreen_native->crtc));
-  kms_device = meta_kms_crtc_get_device (kms_crtc);
+  clutter_frame_set_result (frame,
+                            CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
+
+  meta_frame_native_set_damage (frame_native, rectangles, n_rectangles);
+  onscreen_native->swaps_pending++;
+  try_post_latest_swap (onscreen);
+  return;
+
+swap_failed:
+  frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
+  meta_onscreen_native_notify_frame_complete (onscreen);
+  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
+}
+
+static void
+try_post_latest_swap (CoglOnscreen *onscreen)
+{
+  CoglFramebuffer *framebuffer = COGL_FRAMEBUFFER (onscreen);
+  CoglContext *cogl_context = cogl_framebuffer_get_context (framebuffer);
+  CoglRenderer *cogl_renderer = cogl_context->display->renderer;
+  CoglRendererEGL *cogl_renderer_egl = cogl_renderer->winsys;
+  MetaRendererNativeGpuData *renderer_gpu_data = cogl_renderer_egl->platform;
+  MetaRendererNative *renderer_native = renderer_gpu_data->renderer_native;
+  MetaRenderer *renderer = META_RENDERER (renderer_native);
+  MetaBackend *backend = meta_renderer_get_backend (renderer);
+  MetaBackendNative *backend_native = META_BACKEND_NATIVE (backend);
+  MetaKms *kms = meta_backend_native_get_kms (backend_native);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+  MetaPowerSave power_save_mode;
+  MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  MetaKmsUpdate *kms_update;
+  g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
+  g_autoptr (ClutterFrame) frame = NULL;
+  MetaFrameNative *frame_native;
+  int sync_fd;
+  COGL_TRACE_SCOPED_ANCHOR (MetaRendererNativePostKmsUpdate);
+
+  if (onscreen_native->next_frame == NULL ||
+      onscreen_native->view == NULL ||
+      meta_kms_is_shutting_down (kms))
+    return;
 
   power_save_mode = meta_monitor_manager_get_power_save_mode (monitor_manager);
   if (power_save_mode == META_POWER_SAVE_ON)
     {
+      unsigned int frames_pending =
+        cogl_onscreen_get_pending_frame_count (onscreen);
+      unsigned int posts_pending;
+      int n_rectangles;
+      int *rectangles;
+
+      g_assert (frames_pending >= onscreen_native->swaps_pending);
+      posts_pending = frames_pending - onscreen_native->swaps_pending;
+      if (posts_pending > 0)
+        return;  /* wait for the next frame notification and then try again */
+
+      frame = clutter_frame_ref (onscreen_native->next_frame);
+      frame_native = meta_frame_native_from_frame (frame);
+      n_rectangles = meta_frame_native_get_damage (frame_native, &rectangles);
+
+      if (onscreen_native->swaps_pending == 0)
+        {
+          if (frame_native)
+            {
+              kms_update = meta_frame_native_steal_kms_update (frame_native);
+              if (kms_update)
+                post_finish_frame (onscreen_native, kms_update);
+            }
+          return;
+        }
+
+      drop_stalled_swap (onscreen);
+      onscreen_native->swaps_pending--;
+
       kms_update = meta_frame_native_ensure_kms_update (frame_native,
                                                         kms_device);
       meta_kms_update_add_result_listener (kms_update,
@@ -1470,13 +1653,11 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
     {
       meta_renderer_native_queue_power_save_page_flip (renderer_native,
                                                        onscreen);
-      clutter_frame_set_result (frame,
-                                CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
       return;
     }
 
-  COGL_TRACE_BEGIN_SCOPED (MetaRendererNativePostKmsUpdate,
-                           "Meta::OnscreenNative::swap_buffers_with_damage#post_pending_update()");
+  COGL_TRACE_BEGIN_ANCHORED (MetaRendererNativePostKmsUpdate,
+                             "Meta::OnscreenNative::try_post_latest_swap#post_pending_update()");
 
   switch (renderer_gpu_data->mode)
     {
@@ -1491,8 +1672,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
           kms_update = meta_frame_native_steal_kms_update (frame_native);
           meta_renderer_native_queue_mode_set_update (renderer_native,
                                                       kms_update);
-          clutter_frame_set_result (frame,
-                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       else if (meta_renderer_native_has_pending_mode_set (renderer_native))
@@ -1506,8 +1685,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
 
           meta_frame_native_steal_kms_update (frame_native);
           meta_renderer_native_post_mode_set_updates (renderer_native);
-          clutter_frame_set_result (frame,
-                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       break;
@@ -1523,8 +1700,6 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
                                                       kms_update);
 
           meta_renderer_native_post_mode_set_updates (renderer_native);
-          clutter_frame_set_result (frame,
-                                    CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
           return;
         }
       break;
@@ -1537,9 +1712,10 @@ meta_onscreen_native_swap_buffers_with_damage (CoglOnscreen  *onscreen,
               meta_kms_device_get_path (kms_device));
 
   kms_update = meta_frame_native_steal_kms_update (frame_native);
+  sync_fd = cogl_context_get_latest_sync_fd (cogl_context);
+  meta_kms_update_set_sync_fd (kms_update, sync_fd);
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
-  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
 }
 
 gboolean
@@ -1572,7 +1748,7 @@ meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
   assign_primary_plane (crtc_kms,
                         buffer,
                         test_update,
-                        META_KMS_ASSIGN_PLANE_FLAG_DIRECT_SCANOUT,
+                        META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC,
                         &src_rect,
                         &dst_rect);
 
@@ -1607,11 +1783,15 @@ scanout_result_feedback (const MetaKmsFeedback *kms_feedback,
                         G_IO_ERROR_PERMISSION_DENIED))
     {
       ClutterStageView *view = CLUTTER_STAGE_VIEW (onscreen_native->view);
+      ClutterFrame *posted_frame = onscreen_native->posted_frame;
+      MetaFrameNative *posted_frame_native =
+        meta_frame_native_from_frame (posted_frame);
+      CoglScanout *scanout =
+        meta_frame_native_get_scanout (posted_frame_native);
 
       g_warning ("Direct scanout page flip failed: %s", error->message);
 
-      cogl_scanout_notify_failed (onscreen_native->gbm.next_scanout,
-                                  onscreen);
+      cogl_scanout_notify_failed (scanout, onscreen);
       clutter_stage_view_add_redraw_clip (view, NULL);
       clutter_stage_view_schedule_update_now (view);
     }
@@ -1620,7 +1800,7 @@ scanout_result_feedback (const MetaKmsFeedback *kms_feedback,
   frame_info->flags |= COGL_FRAME_INFO_FLAG_SYMBOLIC;
 
   meta_onscreen_native_notify_frame_complete (onscreen);
-  meta_onscreen_native_clear_next_fb (onscreen);
+  meta_onscreen_native_clear_posted_fb (onscreen);
 }
 
 static const MetaKmsResultListenerVtable scanout_result_listener_vtable = {
@@ -1672,16 +1852,28 @@ meta_onscreen_native_direct_scanout (CoglOnscreen   *onscreen,
       return FALSE;
     }
 
+  /* Our direct scanout frame counts as 1, so more than that means we would
+   * be jumping the queue (and post would fail).
+   */
+  if (cogl_onscreen_get_pending_frame_count (onscreen) > 1)
+    {
+      g_set_error_literal (error,
+                           COGL_SCANOUT_ERROR,
+                           COGL_SCANOUT_ERROR_INHIBITED,
+                           "Direct scanout is inhibited during triple buffering");
+      return FALSE;
+    }
+
   renderer_gpu_data = meta_renderer_native_get_gpu_data (renderer_native,
                                                          render_gpu);
 
   g_warn_if_fail (renderer_gpu_data->mode == META_RENDERER_NATIVE_MODE_GBM);
-  g_warn_if_fail (!onscreen_native->gbm.next_fb);
-  g_warn_if_fail (!onscreen_native->gbm.next_scanout);
 
-  g_set_object (&onscreen_native->gbm.next_scanout, scanout);
-  g_set_object (&onscreen_native->gbm.next_fb,
-                META_DRM_BUFFER (cogl_scanout_get_buffer (scanout)));
+  assign_next_frame (onscreen_native, frame);
+
+  meta_frame_native_set_scanout (frame_native, scanout);
+  meta_frame_native_set_buffer (frame_native,
+                                META_DRM_BUFFER (cogl_scanout_get_buffer (scanout)));
 
   frame_info->cpu_time_before_buffer_swap_us = g_get_monotonic_time ();
 
@@ -1702,7 +1894,7 @@ meta_onscreen_native_direct_scanout (CoglOnscreen   *onscreen,
                                   onscreen_native->view,
                                   onscreen_native->crtc,
                                   kms_update,
-                                  META_KMS_ASSIGN_PLANE_FLAG_DIRECT_SCANOUT,
+                                  META_KMS_ASSIGN_PLANE_FLAG_DISABLE_IMPLICIT_SYNC,
                                   NULL,
                                   0);
 
@@ -1787,11 +1979,15 @@ meta_onscreen_native_before_redraw (CoglOnscreen *onscreen,
                                     ClutterFrame *frame)
 {
   MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
-  MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
-  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
 
-  meta_kms_device_await_flush (meta_kms_crtc_get_device (kms_crtc),
-                               kms_crtc);
+  if (meta_get_debug_paint_flags () & META_DEBUG_PAINT_SYNC_CURSOR_PRIMARY)
+    {
+      MetaCrtcKms *crtc_kms = META_CRTC_KMS (onscreen_native->crtc);
+      MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (crtc_kms);
+
+      meta_kms_device_await_flush (meta_kms_crtc_get_device (kms_crtc), kms_crtc);
+    }
+
   maybe_update_frame_sync (onscreen_native, frame);
 }
 
@@ -1920,22 +2116,79 @@ meta_onscreen_native_finish_frame (CoglOnscreen *onscreen,
   MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
   MetaFrameNative *frame_native = meta_frame_native_from_frame (frame);
   MetaKmsUpdate *kms_update;
+  unsigned int frames_pending = cogl_onscreen_get_pending_frame_count (onscreen);
+  unsigned int swaps_pending = onscreen_native->swaps_pending;
+  unsigned int posts_pending = frames_pending - swaps_pending;
 
-  kms_update = meta_frame_native_steal_kms_update (frame_native);
-  if (!kms_update)
+  onscreen_native->needs_flush |= meta_kms_device_handle_flush (kms_device,
+                                                                kms_crtc);
+
+  if (!meta_frame_native_has_kms_update (frame_native))
     {
-      if (meta_kms_device_handle_flush (kms_device, kms_crtc))
-        {
-          kms_update = meta_kms_update_new (kms_device);
-          meta_kms_update_set_flushing (kms_update, kms_crtc);
-        }
-      else
+      if (!onscreen_native->needs_flush || posts_pending)
         {
           clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
           return;
         }
     }
 
+  if (posts_pending && !swaps_pending)
+    {
+      g_return_if_fail (meta_frame_native_has_kms_update (frame_native));
+      g_warn_if_fail (onscreen_native->next_frame == NULL);
+
+      g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
+      onscreen_native->next_frame = clutter_frame_ref (frame);
+      clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
+      return;
+    }
+
+  kms_update = meta_frame_native_steal_kms_update (frame_native);
+
+  if (posts_pending && swaps_pending)
+    {
+      MetaFrameNative *older_frame_native;
+      MetaKmsUpdate *older_kms_update;
+
+      g_return_if_fail (kms_update);
+      g_return_if_fail (onscreen_native->next_frame != NULL);
+
+      older_frame_native =
+        meta_frame_native_from_frame (onscreen_native->next_frame);
+      older_kms_update =
+        meta_frame_native_ensure_kms_update (older_frame_native, kms_device);
+      meta_kms_update_merge_from (older_kms_update, kms_update);
+      meta_kms_update_free (kms_update);
+      clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_IDLE);
+      return;
+    }
+
+  if (!kms_update)
+    {
+      kms_update = meta_kms_update_new (kms_device);
+      g_warn_if_fail (onscreen_native->needs_flush);
+    }
+
+  if (onscreen_native->needs_flush)
+    {
+      meta_kms_update_set_flushing (kms_update, kms_crtc);
+      onscreen_native->needs_flush = FALSE;
+    }
+
+  post_finish_frame (onscreen_native, kms_update);
+
+  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
+}
+
+static void
+post_finish_frame (MetaOnscreenNative *onscreen_native,
+                   MetaKmsUpdate      *kms_update)
+{
+  MetaCrtc *crtc = onscreen_native->crtc;
+  MetaKmsCrtc *kms_crtc = meta_crtc_kms_get_kms_crtc (META_CRTC_KMS (crtc));
+  MetaKmsDevice *kms_device = meta_kms_crtc_get_device (kms_crtc);
+  g_autoptr (MetaKmsFeedback) kms_feedback = NULL;
+
   meta_kms_update_add_result_listener (kms_update,
                                        &finish_frame_result_listener_vtable,
                                        NULL,
@@ -1958,7 +2211,17 @@ meta_onscreen_native_finish_frame (CoglOnscreen *onscreen,
   meta_kms_update_set_flushing (kms_update, kms_crtc);
   meta_kms_device_post_update (kms_device, kms_update,
                                META_KMS_UPDATE_FLAG_NONE);
-  clutter_frame_set_result (frame, CLUTTER_FRAME_RESULT_PENDING_PRESENTED);
+}
+
+void
+meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen)
+{
+  MetaOnscreenNative *onscreen_native = META_ONSCREEN_NATIVE (onscreen);
+
+  onscreen_native->swaps_pending = 0;
+
+  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
+  g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
 }
 
 static gboolean
@@ -2863,15 +3126,17 @@ meta_onscreen_native_dispose (GObject *object)
 
   meta_onscreen_native_detach (onscreen_native);
 
+  g_clear_pointer (&onscreen_native->next_frame, clutter_frame_unref);
+  g_clear_pointer (&onscreen_native->stalled_frame, clutter_frame_unref);
+  g_clear_pointer (&onscreen_native->posted_frame, clutter_frame_unref);
+  g_clear_pointer (&onscreen_native->presented_frame, clutter_frame_unref);
+
   renderer_gpu_data =
     meta_renderer_native_get_gpu_data (renderer_native,
                                        onscreen_native->render_gpu);
   switch (renderer_gpu_data->mode)
     {
     case META_RENDERER_NATIVE_MODE_GBM:
-      g_clear_object (&onscreen_native->gbm.next_fb);
-      g_clear_object (&onscreen_native->gbm.next_scanout);
-      free_current_bo (onscreen);
       break;
     case META_RENDERER_NATIVE_MODE_SURFACELESS:
       g_assert_not_reached ();
diff --git a/src/backends/native/meta-onscreen-native.h b/src/backends/native/meta-onscreen-native.h
index 0e1193325..e30357d19 100644
--- a/src/backends/native/meta-onscreen-native.h
+++ b/src/backends/native/meta-onscreen-native.h
@@ -48,6 +48,8 @@ void meta_onscreen_native_dummy_power_save_page_flip (CoglOnscreen *onscreen);
 gboolean meta_onscreen_native_is_buffer_scanout_compatible (CoglOnscreen *onscreen,
                                                             CoglScanout  *scanout);
 
+void meta_onscreen_native_discard_pending_swaps (CoglOnscreen *onscreen);
+
 void meta_onscreen_native_set_view (CoglOnscreen     *onscreen,
                                     MetaRendererView *view);
 
diff --git a/src/backends/native/meta-renderer-native.c b/src/backends/native/meta-renderer-native.c
index 2fcf6dfd5..03b41dfca 100644
--- a/src/backends/native/meta-renderer-native.c
+++ b/src/backends/native/meta-renderer-native.c
@@ -731,12 +731,18 @@ static gboolean
 dummy_power_save_page_flip_cb (gpointer user_data)
 {
   MetaRendererNative *renderer_native = user_data;
+  GList *old_list =
+    g_steal_pointer (&renderer_native->power_save_page_flip_onscreens);
 
-  g_list_foreach (renderer_native->power_save_page_flip_onscreens,
+  g_list_foreach (old_list,
                   (GFunc) meta_onscreen_native_dummy_power_save_page_flip,
                   NULL);
-  g_clear_list (&renderer_native->power_save_page_flip_onscreens,
+  g_clear_list (&old_list,
                 g_object_unref);
+
+  if (renderer_native->power_save_page_flip_onscreens != NULL)
+    return G_SOURCE_CONTINUE;
+
   renderer_native->power_save_page_flip_source_id = 0;
 
   return G_SOURCE_REMOVE;
@@ -748,6 +754,9 @@ meta_renderer_native_queue_power_save_page_flip (MetaRendererNative *renderer_na
 {
   const unsigned int timeout_ms = 100;
 
+  if (g_list_find (renderer_native->power_save_page_flip_onscreens, onscreen))
+    return;
+
   if (!renderer_native->power_save_page_flip_source_id)
     {
       renderer_native->power_save_page_flip_source_id =
@@ -1529,6 +1538,26 @@ detach_onscreens (MetaRenderer *renderer)
     }
 }
 
+static void
+discard_pending_swaps (MetaRenderer *renderer)
+{
+  GList *views = meta_renderer_get_views (renderer);;
+  GList *l;
+
+  for (l = views; l; l = l->next)
+    {
+      ClutterStageView *stage_view = l->data;
+      CoglFramebuffer *fb = clutter_stage_view_get_onscreen (stage_view);
+      CoglOnscreen *onscreen;
+
+      if (!COGL_IS_ONSCREEN (fb))
+        continue;
+
+      onscreen = COGL_ONSCREEN (fb);
+      meta_onscreen_native_discard_pending_swaps (onscreen);
+    }
+}
+
 static void
 meta_renderer_native_rebuild_views (MetaRenderer *renderer)
 {
@@ -1539,6 +1568,7 @@ meta_renderer_native_rebuild_views (MetaRenderer *renderer)
   MetaRendererClass *parent_renderer_class =
     META_RENDERER_CLASS (meta_renderer_native_parent_class);
 
+  discard_pending_swaps (renderer);
   meta_kms_discard_pending_page_flips (kms);
   g_hash_table_remove_all (renderer_native->mode_set_updates);
 
diff --git a/src/backends/native/meta-renderer-view-native.c b/src/backends/native/meta-renderer-view-native.c
index a04e2e353..5699f9a55 100644
--- a/src/backends/native/meta-renderer-view-native.c
+++ b/src/backends/native/meta-renderer-view-native.c
@@ -24,6 +24,7 @@
 
 #include "backends/native/meta-renderer-view-native.h"
 
+#include "backends/native/meta-crtc-native.h"
 #include "backends/native/meta-frame-native.h"
 
 struct _MetaRendererViewNative
@@ -34,18 +35,58 @@ struct _MetaRendererViewNative
 G_DEFINE_TYPE (MetaRendererViewNative, meta_renderer_view_native,
                META_TYPE_RENDERER_VIEW)
 
+static void
+update_frame_clock_deadline_evasion (MetaRendererView *renderer_view)
+{
+  ClutterStageView *stage_view = CLUTTER_STAGE_VIEW (renderer_view);
+  ClutterFrameClock *frame_clock;
+  MetaCrtc *crtc;
+  MetaCrtcNative *crtc_native;
+  int64_t deadline_evasion_us;
+
+  frame_clock = clutter_stage_view_get_frame_clock (stage_view);
+  crtc = meta_renderer_view_get_crtc (renderer_view);
+  crtc_native = META_CRTC_NATIVE (crtc);
+
+  deadline_evasion_us = meta_crtc_native_get_deadline_evasion (crtc_native);
+  clutter_frame_clock_set_deadline_evasion (frame_clock,
+                                            deadline_evasion_us);
+}
+
+static void
+meta_renderer_view_native_constructed (GObject *object)
+{
+  MetaRendererView *renderer_view = META_RENDERER_VIEW (object);
+
+  G_OBJECT_CLASS (meta_renderer_view_native_parent_class)->constructed (object);
+
+  update_frame_clock_deadline_evasion (renderer_view);
+}
+
 static ClutterFrame *
 meta_renderer_view_native_new_frame (ClutterStageView *stage_view)
 {
   return (ClutterFrame *) meta_frame_native_new ();
 }
 
+static void
+meta_renderer_view_native_schedule_update (ClutterStageView *stage_view)
+{
+  MetaRendererView *renderer_view = META_RENDERER_VIEW (stage_view);
+
+  update_frame_clock_deadline_evasion (renderer_view);
+}
+
 static void
 meta_renderer_view_native_class_init (MetaRendererViewNativeClass *klass)
 {
+  GObjectClass *object_class = G_OBJECT_CLASS (klass);
   ClutterStageViewClass *stage_view_class = CLUTTER_STAGE_VIEW_CLASS (klass);
 
+  object_class->constructed = meta_renderer_view_native_constructed;
+
   stage_view_class->new_frame = meta_renderer_view_native_new_frame;
+  stage_view_class->schedule_update = meta_renderer_view_native_schedule_update;
 }
 
 static void
diff --git a/src/compositor/meta-window-actor-x11.c b/src/compositor/meta-window-actor-x11.c
index 19827af33..577ed2760 100644
--- a/src/compositor/meta-window-actor-x11.c
+++ b/src/compositor/meta-window-actor-x11.c
@@ -424,6 +424,14 @@ has_shadow (MetaWindowActorX11 *actor_x11)
    */
   if (window->has_custom_frame_extents)
     return FALSE;
+ 
+  /*
+   * OpenJDK wrongly assumes that shaping a window implies no compositor
+   * shadows; make its compliance tests happy to give it what it wants ...
+   */
+  if (g_strcmp0 (window->res_name, "sun-awt-X11-XWindowPeer") == 0 &&
+      meta_window_x11_is_shaped (window))
+    return FALSE;
 
   /*
    * Generate shadows for all other windows.
@@ -688,11 +696,23 @@ meta_window_actor_x11_process_damage (MetaWindowActorX11 *actor_x11,
 
   surface = meta_window_actor_get_surface (META_WINDOW_ACTOR (actor_x11));
   if (surface)
-    meta_surface_actor_process_damage (surface,
-                                       event->area.x,
-                                       event->area.y,
-                                       event->area.width,
-                                       event->area.height);
+    {
+      MetaWindow *window =
+        meta_window_actor_get_meta_window (META_WINDOW_ACTOR (actor_x11));
+      MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+      MtkRectangle damage;
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         event->area.x, event->area.y,
+                                         event->area.width,  event->area.height,
+                                         &damage.x, &damage.y,
+                                         &damage.width, &damage.height);
+      meta_surface_actor_process_damage (surface,
+                                         damage.x,
+                                         damage.y,
+                                         damage.width,
+                                         damage.height);
+    }
 
   meta_window_actor_notify_damaged (META_WINDOW_ACTOR (actor_x11));
 }
diff --git a/src/core/events.c b/src/core/events.c
index 1f36d2feb..a1874d673 100644
--- a/src/core/events.c
+++ b/src/core/events.c
@@ -238,6 +238,7 @@ meta_display_handle_event (MetaDisplay        *display,
 #ifdef HAVE_WAYLAND
   MetaWaylandCompositor *wayland_compositor;
   MetaWaylandTextInput *wayland_text_input = NULL;
+  MetaWaylandTextInputV1 *wayland_text_input_v1 = NULL;
 #endif
 
 #ifdef HAVE_WAYLAND
@@ -246,6 +247,8 @@ meta_display_handle_event (MetaDisplay        *display,
     {
       wayland_text_input =
         meta_wayland_compositor_get_text_input (wayland_compositor);
+      wayland_text_input_v1 =
+        meta_wayland_compositor_get_text_input_v1 (wayland_compositor);
     }
 #endif
 
@@ -287,9 +290,11 @@ meta_display_handle_event (MetaDisplay        *display,
     }
 
 #ifdef HAVE_WAYLAND
-  if (wayland_text_input &&
-      !meta_compositor_get_current_window_drag (compositor) &&
-      meta_wayland_text_input_update (wayland_text_input, event))
+  if (!meta_compositor_get_current_window_drag (compositor) &&
+      ((wayland_text_input &&
+        meta_wayland_text_input_update (wayland_text_input, event)) ||
+       (wayland_text_input_v1 &&
+        meta_wayland_text_input_v1_update (wayland_text_input_v1, event))))
     return CLUTTER_EVENT_STOP;
 
   if (wayland_compositor)
diff --git a/src/core/frame.c b/src/core/frame.c
index 7a09f89f1..57daf00ee 100644
--- a/src/core/frame.c
+++ b/src/core/frame.c
@@ -77,6 +77,7 @@ meta_window_x11_set_frame_xwindow (MetaWindow *window,
   XSetWindowAttributes attrs;
   gulong create_serial = 0;
   g_autoptr (MetaFrame) frame = NULL;
+  int child_x, child_y;
 
   if (window->frame)
     return;
@@ -135,12 +136,19 @@ meta_window_x11_set_frame_xwindow (MetaWindow *window,
   meta_stack_tracker_record_remove (window->display->stack_tracker,
                                     meta_window_x11_get_xwindow (window),
                                     XNextRequest (x11_display->xdisplay));
+  meta_window_x11_stage_to_protocol (META_WINDOW_X11 (window),
+                                     frame->child_x,
+                                     frame->child_y,
+                                     0, 0,
+                                     &child_x,
+                                     &child_y,
+                                     NULL, NULL);
 
   XReparentWindow (x11_display->xdisplay,
                    meta_window_x11_get_xwindow (window),
                    frame->xwindow,
-                   frame->child_x,
-                   frame->child_y);
+                   child_x,
+                   child_y);
 
   if (mtk_x11_error_trap_pop_with_return (x11_display->xdisplay))
     {
@@ -235,6 +243,8 @@ meta_window_destroy_frame (MetaWindow *window)
 
   if (!x11_display->closing)
     {
+      int child_x, child_y;
+
       if (!window->unmanaging)
         {
           meta_stack_tracker_record_add (window->display->stack_tracker,
@@ -242,6 +252,14 @@ meta_window_destroy_frame (MetaWindow *window)
                                          XNextRequest (x11_display->xdisplay));
         }
 
+      meta_window_x11_stage_to_protocol (META_WINDOW_X11 (window),
+                                         frame->rect.x + borders.invisible.left,
+                                         frame->rect.y + borders.invisible.top,
+                                         0, 0,
+                                         &child_x,
+                                         &child_y,
+                                         NULL, NULL);
+
       XReparentWindow (x11_display->xdisplay,
                        meta_window_x11_get_xwindow (window),
                        x11_display->xroot,
@@ -249,8 +267,7 @@ meta_window_destroy_frame (MetaWindow *window)
                         * coordinates here means we'll need to ensure a configure
                         * notify event is sent; see bug 399552.
                         */
-                       frame->rect.x + borders.invisible.left,
-                       frame->rect.y + borders.invisible.top);
+                       child_x, child_y);
       window->reparents_pending += 1;
     }
 
@@ -297,6 +314,7 @@ meta_frame_query_borders (MetaFrame        *frame,
                           MetaFrameBorders *borders)
 {
   MetaWindow *window = frame->window;
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaX11Display *x11_display = window->display->x11_display;
   int format, res;
   Atom type;
@@ -320,12 +338,22 @@ meta_frame_query_borders (MetaFrame        *frame,
   if (mtk_x11_error_trap_pop_with_return (x11_display->xdisplay) == Success &&
       res == Success && nitems == 4)
     {
-      borders->invisible = (MetaFrameBorder) {
-        ((long *) data)[0],
-        ((long *) data)[1],
-        ((long *) data)[2],
-        ((long *) data)[3],
-      };
+      int left, right, top, bottom;
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         ((long *) data)[0],
+                                         ((long *) data)[1],
+                                         ((long *) data)[2],
+                                         ((long *) data)[3],
+                                         &left,
+                                         &right,
+                                         &top,
+                                         &bottom);
+
+      borders->invisible.left = left;
+      borders->invisible.right = right;
+      borders->invisible.top = top;
+      borders->invisible.bottom = bottom;
     }
   else
     {
@@ -348,12 +376,21 @@ meta_frame_query_borders (MetaFrame        *frame,
   if (mtk_x11_error_trap_pop_with_return (x11_display->xdisplay) == Success &&
       res == Success && nitems == 4)
     {
-      borders->visible = (MetaFrameBorder) {
-        ((long *) data)[0],
-        ((long *) data)[1],
-        ((long *) data)[2],
-        ((long *) data)[3],
-      };
+      int left, right, top, bottom;
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         ((long *) data)[0],
+                                         ((long *) data)[1],
+                                         ((long *) data)[2],
+                                         ((long *) data)[3],
+                                         &left,
+                                         &right,
+                                         &top,
+                                         &bottom);
+      borders->visible.left = left;
+      borders->visible.right = right;
+      borders->visible.top = top;
+      borders->visible.bottom = bottom;
     }
   else
     {
@@ -401,7 +438,9 @@ meta_frame_sync_to_window (MetaFrame *frame,
                            gboolean   need_resize)
 {
   MetaWindow *window = frame->window;
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaX11Display *x11_display = window->display->x11_display;
+  MtkRectangle rect;
 
   meta_topic (META_DEBUG_GEOMETRY,
               "Syncing frame geometry %d,%d %dx%d (SE: %d,%d)",
@@ -412,12 +451,22 @@ meta_frame_sync_to_window (MetaFrame *frame,
 
   mtk_x11_error_trap_push (x11_display->xdisplay);
 
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     frame->rect.x,
+                                     frame->rect.y,
+                                     frame->rect.width,
+                                     frame->rect.height,
+                                     &rect.x,
+                                     &rect.y,
+                                     &rect.width,
+                                     &rect.height);
+
   XMoveResizeWindow (x11_display->xdisplay,
                      frame->xwindow,
-                     frame->rect.x,
-                     frame->rect.y,
-                     frame->rect.width,
-                     frame->rect.height);
+                     rect.x,
+                     rect.y,
+                     rect.width,
+                     rect.height);
 
   mtk_x11_error_trap_pop (x11_display->xdisplay);
 
@@ -454,6 +503,7 @@ static void
 send_configure_notify (MetaFrame *frame)
 {
   MetaX11Display *x11_display = frame->window->display->x11_display;
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (frame->window);
   XEvent event = { 0 };
 
   /* We never get told by the frames client, just reassert the
@@ -463,10 +513,16 @@ send_configure_notify (MetaFrame *frame)
   event.xconfigure.display = x11_display->xdisplay;
   event.xconfigure.event = frame->xwindow;
   event.xconfigure.window = frame->xwindow;
-  event.xconfigure.x = frame->rect.x;
-  event.xconfigure.y = frame->rect.y;
-  event.xconfigure.width = frame->rect.width;
-  event.xconfigure.height = frame->rect.height;
+
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     frame->rect.x,
+                                     frame->rect.y,
+                                     frame->rect.width,
+                                     frame->rect.height,
+                                     &event.xconfigure.x,
+                                     &event.xconfigure.y,
+                                     &event.xconfigure.width,
+                                     &event.xconfigure.height);
   event.xconfigure.border_width = 0;
   event.xconfigure.above = None;
   event.xconfigure.override_redirect = False;
diff --git a/src/core/place.c b/src/core/place.c
index 23eb68e7f..41c816e65 100644
--- a/src/core/place.c
+++ b/src/core/place.c
@@ -381,6 +381,11 @@ window_place_centered (MetaWindow *window)
 
   type = window->type;
 
+  if (g_strcmp0 (meta_window_get_wm_class (window), "org.gnome.InitialSetup") == 0 ||
+      g_strcmp0 (meta_window_get_wm_class (window), "org.fedoraproject.welcome-screen") == 0 ||
+      g_strcmp0 (meta_window_get_wm_class (window), "fedora-welcome") == 0)
+    return TRUE;
+
   return (type == META_WINDOW_DIALOG ||
     type == META_WINDOW_MODAL_DIALOG ||
     type == META_WINDOW_SPLASHSCREEN ||
diff --git a/src/core/util.c b/src/core/util.c
index 05a0dea39..f8a08c747 100644
--- a/src/core/util.c
+++ b/src/core/util.c
@@ -69,6 +69,7 @@ static const GDebugKey meta_debug_keys[] = {
   { "color", META_DEBUG_COLOR },
   { "input-events", META_DEBUG_INPUT_EVENTS },
   { "eis", META_DEBUG_EIS },
+  { "kms-deadline", META_DEBUG_KMS_DEADLINE },
 };
 
 static gint verbose_topics = 0;
@@ -326,6 +327,8 @@ meta_topic_to_string (MetaDebugTopic topic)
       return "INPUT_EVENTS";
     case META_DEBUG_EIS:
       return "EIS";
+    case META_DEBUG_KMS_DEADLINE:
+      return "KMS_DEADLINE";
     }
 
   return "WM";
diff --git a/src/meson.build b/src/meson.build
index 05df3bfd2..56ca368a7 100644
--- a/src/meson.build
+++ b/src/meson.build
@@ -688,6 +688,8 @@ if have_wayland
     'wayland/meta-wayland-tablet-tool.h',
     'wayland/meta-wayland-text-input.c',
     'wayland/meta-wayland-text-input.h',
+    'wayland/meta-wayland-text-input-v1.c',
+    'wayland/meta-wayland-text-input-v1.h',
     'wayland/meta-wayland-touch.c',
     'wayland/meta-wayland-touch.h',
     'wayland/meta-wayland-transaction.c',
@@ -949,6 +951,11 @@ dbus_interfaces = [
     'interface': 'org.gnome.Mutter.DebugControl.xml',
     'prefix': 'org.gnome.Mutter',
   },
+  {
+    'name': 'meta-dbus-x11',
+    'interface': 'org.gnome.Mutter.X11.xml',
+    'prefix': 'org.gnome.Mutter',
+  },
 ]
 
 if have_profiler
@@ -1076,6 +1083,7 @@ if have_wayland
     ['single-pixel-buffer', 'staging', 'v1', ],
     ['tablet', 'unstable', 'v2', ],
     ['text-input', 'unstable', 'v3', ],
+    ['text-input', 'unstable', 'v1', ],
     ['viewporter', 'stable', ],
     ['xdg-activation', 'staging', 'v1', ],
     ['xdg-foreign', 'unstable', 'v1', ],
diff --git a/src/meta/meta-context.h b/src/meta/meta-context.h
index ef36bd2c3..2adb9b07e 100644
--- a/src/meta/meta-context.h
+++ b/src/meta/meta-context.h
@@ -101,3 +101,8 @@ gboolean meta_context_raise_rlimit_nofile (MetaContext  *context,
 META_EXPORT
 gboolean meta_context_restore_rlimit_nofile (MetaContext  *context,
                                              GError      **error);
+
+#ifdef HAVE_WAYLAND
+META_EXPORT
+MetaWaylandCompositor * meta_context_get_wayland_compositor (MetaContext *context);
+#endif
diff --git a/src/meta/meta-debug.h b/src/meta/meta-debug.h
index b4c70144b..2de9a89d7 100644
--- a/src/meta/meta-debug.h
+++ b/src/meta/meta-debug.h
@@ -50,6 +50,7 @@
  * @META_DEBUG_COLOR: color management
  * @META_DEBUG_INPUT_EVENTS: input events
  * @META_DEBUG_EIS: eis state
+ * @META_DEBUG_KMS_DEADLINE: KMS deadline timers
  */
 typedef enum
 {
@@ -83,6 +84,7 @@ typedef enum
   META_DEBUG_COLOR           = 1 << 26,
   META_DEBUG_INPUT_EVENTS    = 1 << 27,
   META_DEBUG_EIS             = 1 << 28,
+  META_DEBUG_KMS_DEADLINE    = 1 << 29,
 } MetaDebugTopic;
 
 META_EXPORT
diff --git a/src/meta/meta-wayland-compositor.h b/src/meta/meta-wayland-compositor.h
index 7f4a50705..3df92fda5 100644
--- a/src/meta/meta-wayland-compositor.h
+++ b/src/meta/meta-wayland-compositor.h
@@ -31,9 +31,6 @@ G_DECLARE_FINAL_TYPE (MetaWaylandCompositor,
                       META, WAYLAND_COMPOSITOR,
                       GObject)
 
-META_EXPORT
-MetaWaylandCompositor *meta_context_get_wayland_compositor (MetaContext *context);
-
 META_EXPORT
 struct wl_display *meta_wayland_compositor_get_wayland_display (MetaWaylandCompositor *compositor);
 
diff --git a/src/meta/types.h b/src/meta/types.h
index cbe2a9a3d..8fba4a839 100644
--- a/src/meta/types.h
+++ b/src/meta/types.h
@@ -38,3 +38,7 @@ typedef struct _MetaSettings    MetaSettings;
 
 typedef struct _MetaWorkspaceManager MetaWorkspaceManager;
 typedef struct _MetaSelection   MetaSelection;
+
+#ifdef HAVE_WAYLAND
+typedef struct _MetaWaylandCompositor MetaWaylandCompositor;
+#endif
diff --git a/src/meta/util.h b/src/meta/util.h
index ca8ca2ade..91ca6a836 100644
--- a/src/meta/util.h
+++ b/src/meta/util.h
@@ -51,11 +51,14 @@ void meta_fatal      (const char *format,
  * MetaDebugPaintFlag:
  * @META_DEBUG_PAINT_NONE: default
  * @META_DEBUG_PAINT_OPAQUE_REGION: paint opaque regions
+ * @META_DEBUG_PAINT_SYNC_CURSOR_PRIMARY: make cursor updates await compositing
+ *   frames
  */
 typedef enum
 {
   META_DEBUG_PAINT_NONE          = 0,
   META_DEBUG_PAINT_OPAQUE_REGION = 1 << 0,
+  META_DEBUG_PAINT_SYNC_CURSOR_PRIMARY = 1 << 1,
 } MetaDebugPaintFlag;
 
 META_EXPORT
diff --git a/src/tests/meta-monitor-manager-test.c b/src/tests/meta-monitor-manager-test.c
index f9275160c..fd37eab38 100644
--- a/src/tests/meta-monitor-manager-test.c
+++ b/src/tests/meta-monitor-manager-test.c
@@ -517,6 +517,12 @@ meta_crtc_test_set_gamma_lut (MetaCrtc           *crtc,
                                      sizeof (uint16_t) * lut->size);
 }
 
+static int64_t
+meta_crtc_test_get_deadline_evasion (MetaCrtcNative *crtc_native)
+{
+  return 0;
+}
+
 static void
 meta_crtc_test_finalize (GObject *object)
 {
diff --git a/src/tests/native-kms-render.c b/src/tests/native-kms-render.c
index f5ebc23fe..2f870fdc3 100644
--- a/src/tests/native-kms-render.c
+++ b/src/tests/native-kms-render.c
@@ -39,6 +39,8 @@
 #include "tests/meta-wayland-test-driver.h"
 #include "tests/meta-wayland-test-utils.h"
 
+#define N_FRAMES_PER_TEST 30
+
 typedef struct
 {
   int number_of_frames_left;
@@ -46,12 +48,15 @@ typedef struct
 
   struct {
     int n_paints;
-    uint32_t fb_id;
+    int n_presentations;
+    int n_direct_scanouts;
+    GList *fb_ids;
   } scanout;
 
   gboolean wait_for_scanout;
 
   struct {
+    int scanouts_attempted;
     gboolean scanout_sabotaged;
     gboolean fallback_painted;
     guint repaint_guard_id;
@@ -101,7 +106,7 @@ meta_test_kms_render_basic (void)
   gulong handler_id;
 
   test = (KmsRenderingTest) {
-    .number_of_frames_left = 10,
+    .number_of_frames_left = N_FRAMES_PER_TEST,
     .loop = g_main_loop_new (NULL, FALSE),
   };
   handler_id = g_signal_connect (stage, "after-update",
@@ -123,7 +128,6 @@ on_scanout_before_update (ClutterStage     *stage,
                           KmsRenderingTest *test)
 {
   test->scanout.n_paints = 0;
-  test->scanout.fb_id = 0;
 }
 
 static void
@@ -135,6 +139,7 @@ on_scanout_before_paint (ClutterStage     *stage,
   CoglScanout *scanout;
   CoglScanoutBuffer *scanout_buffer;
   MetaDrmBuffer *buffer;
+  uint32_t fb_id;
 
   scanout = clutter_stage_view_peek_scanout (stage_view);
   if (!scanout)
@@ -143,8 +148,13 @@ on_scanout_before_paint (ClutterStage     *stage,
   scanout_buffer = cogl_scanout_get_buffer (scanout);
   g_assert_true (META_IS_DRM_BUFFER (scanout_buffer));
   buffer = META_DRM_BUFFER (scanout_buffer);
-  test->scanout.fb_id = meta_drm_buffer_get_fb_id (buffer);
-  g_assert_cmpuint (test->scanout.fb_id, >, 0);
+  fb_id = meta_drm_buffer_get_fb_id (buffer);
+  g_assert_cmpuint (fb_id, >, 0);
+  test->scanout.fb_ids = g_list_append (test->scanout.fb_ids,
+                                        GUINT_TO_POINTER (fb_id));
+
+  /* Triple buffering, but no higher */
+  g_assert_cmpuint (g_list_length (test->scanout.fb_ids), <=, 2);
 }
 
 static void
@@ -173,12 +183,12 @@ on_scanout_presented (ClutterStage     *stage,
   MetaDeviceFile *device_file;
   GError *error = NULL;
   drmModeCrtc *drm_crtc;
+  uint32_t first_fb_id_expected;
 
-  if (test->wait_for_scanout && test->scanout.n_paints > 0)
+  if (test->wait_for_scanout && test->scanout.fb_ids == NULL)
     return;
 
-  if (test->wait_for_scanout && test->scanout.fb_id == 0)
-    return;
+  test->scanout.n_presentations++;
 
   device_pool = meta_backend_native_get_device_pool (backend_native);
 
@@ -197,15 +207,41 @@ on_scanout_presented (ClutterStage     *stage,
   drm_crtc = drmModeGetCrtc (meta_device_file_get_fd (device_file),
                              meta_kms_crtc_get_id (kms_crtc));
   g_assert_nonnull (drm_crtc);
-  if (test->scanout.fb_id == 0)
-    g_assert_cmpuint (drm_crtc->buffer_id, !=, test->scanout.fb_id);
+
+  if (test->scanout.fb_ids)
+    {
+      test->scanout.n_direct_scanouts++;
+      first_fb_id_expected = GPOINTER_TO_UINT (test->scanout.fb_ids->data);
+      test->scanout.fb_ids = g_list_delete_link (test->scanout.fb_ids,
+                                                 test->scanout.fb_ids);
+    }
   else
-    g_assert_cmpuint (drm_crtc->buffer_id, ==, test->scanout.fb_id);
+    {
+      first_fb_id_expected = 0;
+    }
+
+  /* The buffer ID won't match on the first frame because switching from
+   * triple buffered compositing to double buffered direct scanout takes
+   * an extra frame to drain the queue. Thereafter we are in direct scanout
+   * mode and expect the buffer IDs to match.
+   */
+  if (test->scanout.n_presentations > 1)
+    {
+      if (first_fb_id_expected == 0)
+        g_assert_cmpuint (drm_crtc->buffer_id, !=, first_fb_id_expected);
+      else
+        g_assert_cmpuint (drm_crtc->buffer_id, ==, first_fb_id_expected);
+    }
+
   drmModeFreeCrtc (drm_crtc);
 
   meta_device_file_release (device_file);
 
-  g_main_loop_quit (test->loop);
+  test->number_of_frames_left--;
+  if (test->number_of_frames_left <= 0)
+    g_main_loop_quit (test->loop);
+  else
+    clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
 }
 
 typedef enum
@@ -244,7 +280,9 @@ meta_test_kms_render_client_scanout (void)
   g_assert_nonnull (wayland_test_client);
 
   test = (KmsRenderingTest) {
+    .number_of_frames_left = N_FRAMES_PER_TEST,
     .loop = g_main_loop_new (NULL, FALSE),
+    .scanout = {0},
     .wait_for_scanout = TRUE,
   };
 
@@ -270,7 +308,8 @@ meta_test_kms_render_client_scanout (void)
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpuint (test.scanout.fb_id, >, 0);
+  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
+  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, N_FRAMES_PER_TEST);
 
   g_debug ("Unmake fullscreen");
   window = meta_find_window_from_title (test_context, "dma-buf-scanout-test");
@@ -292,10 +331,15 @@ meta_test_kms_render_client_scanout (void)
   g_assert_cmpint (buffer_rect.y, ==, 10);
 
   test.wait_for_scanout = FALSE;
+  test.number_of_frames_left = N_FRAMES_PER_TEST;
+  test.scanout.n_presentations = 0;
+  test.scanout.n_direct_scanouts = 0;
+
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpuint (test.scanout.fb_id, ==, 0);
+  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
+  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, 0);
 
   g_debug ("Moving back to 0, 0");
   meta_window_move_frame (window, TRUE, 0, 0);
@@ -307,10 +351,15 @@ meta_test_kms_render_client_scanout (void)
   g_assert_cmpint (buffer_rect.y, ==, 0);
 
   test.wait_for_scanout = TRUE;
+  test.number_of_frames_left = N_FRAMES_PER_TEST;
+  test.scanout.n_presentations = 0;
+  test.scanout.n_direct_scanouts = 0;
+
   clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
   g_main_loop_run (test.loop);
 
-  g_assert_cmpuint (test.scanout.fb_id, >, 0);
+  g_assert_cmpint (test.scanout.n_presentations, ==, N_FRAMES_PER_TEST);
+  g_assert_cmpint (test.scanout.n_direct_scanouts, ==, N_FRAMES_PER_TEST);
 
   g_signal_handler_disconnect (stage, before_update_handler_id);
   g_signal_handler_disconnect (stage, before_paint_handler_id);
@@ -364,6 +413,15 @@ on_scanout_fallback_before_paint (ClutterStage     *stage,
   if (!scanout)
     return;
 
+  test->scanout_fallback.scanouts_attempted++;
+
+  /* The first scanout candidate frame will get composited due to triple
+   * buffering draining the queue to drop to double buffering. So don't
+   * sabotage that first frame.
+   */
+  if (test->scanout_fallback.scanouts_attempted < 2)
+    return;
+
   g_assert_false (test->scanout_fallback.scanout_sabotaged);
 
   if (is_atomic_mode_setting (kms_device))
@@ -401,6 +459,15 @@ on_scanout_fallback_paint_view (ClutterStage     *stage,
       g_clear_handle_id (&test->scanout_fallback.repaint_guard_id,
                          g_source_remove);
       test->scanout_fallback.fallback_painted = TRUE;
+      test->scanout_fallback.scanout_sabotaged = FALSE;
+    }
+  else if (test->scanout_fallback.scanouts_attempted == 1)
+    {
+      /* Now that we've seen the first scanout attempt that was inhibited by
+       * triple buffering, try a second frame. The second one should scanout
+       * and will be sabotaged.
+       */
+      clutter_actor_queue_redraw (CLUTTER_ACTOR (stage));
     }
 }
 
@@ -410,11 +477,11 @@ on_scanout_fallback_presented (ClutterStage     *stage,
                                ClutterFrameInfo *frame_info,
                                KmsRenderingTest *test)
 {
-  if (!test->scanout_fallback.scanout_sabotaged)
-    return;
+  if (test->scanout_fallback.fallback_painted)
+    g_main_loop_quit (test->loop);
 
-  g_assert_true (test->scanout_fallback.fallback_painted);
-  g_main_loop_quit (test->loop);
+  test->number_of_frames_left--;
+  g_assert_cmpint (test->number_of_frames_left, >, 0);
 }
 
 static void
@@ -443,6 +510,7 @@ meta_test_kms_render_client_scanout_fallback (void)
   g_assert_nonnull (wayland_test_client);
 
   test = (KmsRenderingTest) {
+    .number_of_frames_left = N_FRAMES_PER_TEST,
     .loop = g_main_loop_new (NULL, FALSE),
   };
 
diff --git a/src/wayland/meta-wayland-cursor-surface.c b/src/wayland/meta-wayland-cursor-surface.c
index 87a8895c8..5a16ce7d8 100644
--- a/src/wayland/meta-wayland-cursor-surface.c
+++ b/src/wayland/meta-wayland-cursor-surface.c
@@ -92,37 +92,29 @@ cursor_sprite_prepare_at (MetaCursorSprite         *cursor_sprite,
 {
   MetaWaylandSurfaceRole *role = META_WAYLAND_SURFACE_ROLE (cursor_surface);
   MetaWaylandSurface *surface = meta_wayland_surface_role_get_surface (role);
-
-  if (!meta_wayland_surface_is_xwayland (surface))
+  MetaContext *context =
+    meta_wayland_compositor_get_context (surface->compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaLogicalMonitor *logical_monitor;
+
+  logical_monitor =
+    meta_monitor_manager_get_logical_monitor_at (monitor_manager, x, y);
+  if (logical_monitor)
     {
-      MetaWaylandSurfaceRole *surface_role =
-        META_WAYLAND_SURFACE_ROLE (cursor_surface);
-      MetaWaylandSurface *surface =
-        meta_wayland_surface_role_get_surface (surface_role);
-      MetaContext *context =
-        meta_wayland_compositor_get_context (surface->compositor);
-      MetaBackend *backend = meta_context_get_backend (context);
-      MetaMonitorManager *monitor_manager =
-        meta_backend_get_monitor_manager (backend);
-      MetaLogicalMonitor *logical_monitor;
-
-      logical_monitor =
-        meta_monitor_manager_get_logical_monitor_at (monitor_manager, x, y);
-      if (logical_monitor)
-        {
-          int surface_scale = surface->applied_state.scale;
-          float texture_scale;
-
-          if (meta_backend_is_stage_views_scaled (backend))
-            texture_scale = 1.0 / surface_scale;
-          else
-            texture_scale = (meta_logical_monitor_get_scale (logical_monitor) /
-                             surface_scale);
-
-          meta_cursor_sprite_set_texture_scale (cursor_sprite, texture_scale);
-          meta_cursor_sprite_set_texture_transform (cursor_sprite,
-                                                    surface->buffer_transform);
-        }
+      int surface_scale = surface->applied_state.scale;
+      float texture_scale;
+
+      if (meta_backend_is_stage_views_scaled (backend))
+        texture_scale = 1.0 / surface_scale;
+      else
+        texture_scale = (meta_logical_monitor_get_scale (logical_monitor) /
+                         surface_scale);
+
+      meta_cursor_sprite_set_texture_scale (cursor_sprite, texture_scale);
+      meta_cursor_sprite_set_texture_transform (cursor_sprite,
+                                                surface->buffer_transform);
     }
 
   meta_wayland_surface_update_outputs (surface);
diff --git a/src/wayland/meta-wayland-outputs.c b/src/wayland/meta-wayland-outputs.c
index 89ae86445..f957bc339 100644
--- a/src/wayland/meta-wayland-outputs.c
+++ b/src/wayland/meta-wayland-outputs.c
@@ -31,6 +31,10 @@
 #include "backends/meta-monitor-manager-private.h"
 #include "wayland/meta-wayland-private.h"
 
+#ifdef HAVE_XWAYLAND
+#include "wayland/meta-xwayland.h"
+#endif
+
 #include "xdg-output-unstable-v1-server-protocol.h"
 
 /* Wayland protocol headers list new additions, not deprecations */
@@ -50,6 +54,8 @@ struct _MetaWaylandOutput
 {
   GObject parent;
 
+  MetaWaylandCompositor *compositor;
+
   struct wl_global *global;
   GList *resources;
   GList *xdg_output_resources;
@@ -422,6 +428,7 @@ meta_wayland_output_new (MetaWaylandCompositor *compositor,
   MetaWaylandOutput *wayland_output;
 
   wayland_output = g_object_new (META_TYPE_WAYLAND_OUTPUT, NULL);
+  wayland_output->compositor = compositor;
   wayland_output->global = wl_global_create (compositor->wayland_display,
                                              &wl_output_interface,
                                              META_WL_OUTPUT_VERSION,
@@ -596,6 +603,37 @@ static const struct zxdg_output_v1_interface
     meta_xdg_output_destroy,
   };
 
+#ifdef HAVE_XWAYLAND
+static gboolean
+is_xwayland_resource (MetaWaylandOutput  *wayland_output,
+                      struct wl_resource *resource)
+{
+  MetaXWaylandManager *manager = &wayland_output->compositor->xwayland_manager;
+
+  return resource && wl_resource_get_client (resource) == manager->client;
+}
+#endif
+
+static void
+maybe_scale_for_xwayland (MetaWaylandOutput  *wayland_output,
+                          struct wl_resource *resource,
+                          int                *x,
+                          int                *y)
+{
+#ifdef HAVE_XWAYLAND
+  if (is_xwayland_resource (wayland_output, resource))
+    {
+      MetaXWaylandManager *xwayland_manager =
+        &wayland_output->compositor->xwayland_manager;
+      int xwayland_scale;
+
+      xwayland_scale = meta_xwayland_get_effective_scale (xwayland_manager);
+      *x *= xwayland_scale;
+      *y *= xwayland_scale;
+    }
+#endif
+}
+
 static void
 send_xdg_output_events (struct wl_resource *resource,
                         MetaWaylandOutput  *wayland_output,
@@ -616,6 +654,7 @@ send_xdg_output_events (struct wl_resource *resource,
   if (need_all_events ||
       old_layout.x != layout.x || old_layout.y != layout.y)
     {
+      maybe_scale_for_xwayland (wayland_output, resource, &layout.x, &layout.y);
       zxdg_output_v1_send_logical_position (resource, layout.x, layout.y);
       need_done = TRUE;
     }
@@ -623,6 +662,7 @@ send_xdg_output_events (struct wl_resource *resource,
   if (need_all_events ||
       old_layout.width != layout.width || old_layout.height != layout.height)
     {
+      maybe_scale_for_xwayland (wayland_output, resource, &layout.width, &layout.height);
       zxdg_output_v1_send_logical_size (resource, layout.width, layout.height);
       need_done = TRUE;
     }
@@ -745,7 +785,7 @@ meta_wayland_outputs_init (MetaWaylandCompositor *compositor)
   MetaMonitorManager *monitor_manager =
     meta_backend_get_monitor_manager (backend);
 
-  g_signal_connect (monitor_manager, "monitors-changed-internal",
+  g_signal_connect (monitor_manager, "monitors-changed",
                     G_CALLBACK (on_monitors_changed), compositor);
 
   compositor->outputs =
diff --git a/src/wayland/meta-wayland-pointer.c b/src/wayland/meta-wayland-pointer.c
index cf6008064..b8c49849a 100644
--- a/src/wayland/meta-wayland-pointer.c
+++ b/src/wayland/meta-wayland-pointer.c
@@ -1247,6 +1247,20 @@ pointer_set_cursor (struct wl_client *client,
       cursor_surface = META_WAYLAND_CURSOR_SURFACE (surface->role);
       meta_wayland_cursor_surface_set_renderer (cursor_surface,
                                                 cursor_renderer);
+
+#ifdef HAVE_XWAYLAND
+      if (meta_wayland_surface_is_xwayland (surface))
+        {
+          MetaXWaylandManager *xwayland_manager =
+            &surface->compositor->xwayland_manager;
+          int scale;
+
+          scale = meta_xwayland_get_effective_scale (xwayland_manager);
+          hot_x = round (hot_x / (double) scale);
+          hot_y = round (hot_y / (double) scale);
+        }
+#endif
+
       meta_wayland_cursor_surface_set_hotspot (cursor_surface,
                                                hot_x, hot_y);
 
diff --git a/src/wayland/meta-wayland-private.h b/src/wayland/meta-wayland-private.h
index e8d442c03..834753ffd 100644
--- a/src/wayland/meta-wayland-private.h
+++ b/src/wayland/meta-wayland-private.h
@@ -77,6 +77,8 @@ struct _MetaXWaylandManager
   int rr_error_base;
 
   gboolean should_enable_ei_portal;
+
+  double highest_monitor_scale;
 };
 
 struct _MetaWaylandCompositor
diff --git a/src/wayland/meta-wayland-seat.c b/src/wayland/meta-wayland-seat.c
index 3e521ae2f..142bf56bc 100644
--- a/src/wayland/meta-wayland-seat.c
+++ b/src/wayland/meta-wayland-seat.c
@@ -232,6 +232,7 @@ default_focus (MetaWaylandEventHandler *handler,
                                                   surface);
       meta_wayland_tablet_seat_set_pad_focus (seat->tablet_seat, surface);
       meta_wayland_text_input_set_focus (seat->text_input, surface);
+      /* text-input-v1 will set focused surface on activate. */
     }
 
   if (caps & CLUTTER_INPUT_CAPABILITY_TABLET_TOOL)
@@ -293,6 +294,8 @@ meta_wayland_seat_new (MetaWaylandCompositor *compositor,
                               NULL);
 
   seat->text_input = meta_wayland_text_input_new (seat);
+  /* Chromium/Electron-based apps only support text-input-v1. */
+  seat->text_input_v1 = meta_wayland_text_input_v1_new (seat);
 
   meta_wayland_data_device_init (&seat->data_device, seat);
   meta_wayland_data_device_primary_init (&seat->primary_data_device, seat);
@@ -341,6 +344,7 @@ meta_wayland_seat_free (MetaWaylandSeat *seat)
   g_object_unref (seat->touch);
 
   meta_wayland_text_input_destroy (seat->text_input);
+  meta_wayland_text_input_v1_destroy (seat->text_input_v1);
 
   g_free (seat);
 }
@@ -493,7 +497,10 @@ meta_wayland_seat_handle_event_internal (MetaWaylandSeat    *seat,
   if (event_type == CLUTTER_BUTTON_PRESS ||
       event_type == CLUTTER_TOUCH_BEGIN)
     {
-      meta_wayland_text_input_handle_event (seat->text_input, event);
+      gboolean handled = FALSE;
+      handled = meta_wayland_text_input_handle_event (seat->text_input, event);
+      if (!handled)
+        handled = meta_wayland_text_input_v1_handle_event (seat->text_input_v1, event);
     }
 
   switch (event_type)
@@ -525,7 +532,8 @@ meta_wayland_seat_handle_event_internal (MetaWaylandSeat    *seat,
     case CLUTTER_IM_COMMIT:
     case CLUTTER_IM_DELETE:
     case CLUTTER_IM_PREEDIT:
-      if (meta_wayland_text_input_handle_event (seat->text_input, event))
+      if (meta_wayland_text_input_handle_event (seat->text_input, event) ||
+          meta_wayland_text_input_v1_handle_event (seat->text_input_v1, event))
         return TRUE;
 
       break;
diff --git a/src/wayland/meta-wayland-seat.h b/src/wayland/meta-wayland-seat.h
index 83fd7de1e..37704cf5a 100644
--- a/src/wayland/meta-wayland-seat.h
+++ b/src/wayland/meta-wayland-seat.h
@@ -30,6 +30,7 @@
 #include "wayland/meta-wayland-pointer.h"
 #include "wayland/meta-wayland-tablet-tool.h"
 #include "wayland/meta-wayland-text-input.h"
+#include "wayland/meta-wayland-text-input-v1.h"
 #include "wayland/meta-wayland-touch.h"
 #include "wayland/meta-wayland-types.h"
 
@@ -49,6 +50,7 @@ struct _MetaWaylandSeat
   MetaWaylandDataDevicePrimary primary_data_device;
 
   MetaWaylandTextInput *text_input;
+  MetaWaylandTextInputV1 *text_input_v1;
 
   MetaWaylandInput *input_handler;
   MetaWaylandEventHandler *default_handler;
diff --git a/src/wayland/meta-wayland-surface.c b/src/wayland/meta-wayland-surface.c
index d8b36ff92..4ad95cd9d 100644
--- a/src/wayland/meta-wayland-surface.c
+++ b/src/wayland/meta-wayland-surface.c
@@ -782,8 +782,19 @@ meta_wayland_surface_apply_state (MetaWaylandSurface      *surface,
           state->buffer->type != META_WAYLAND_BUFFER_TYPE_SINGLE_PIXEL));
     }
 
-  if (state->scale > 0)
-    surface->applied_state.scale = state->scale;
+  if (meta_wayland_surface_is_xwayland (surface))
+    {
+#ifdef HAVE_XWAYLAND
+      MetaXWaylandManager *xwayland_manager =
+        &surface->compositor->xwayland_manager;
+
+      surface->applied_state.scale = meta_xwayland_get_effective_scale (xwayland_manager);
+#endif
+    }
+  else if (state->scale > 0)
+    {
+      surface->applied_state.scale = state->scale;
+    }
 
   if (state->has_new_buffer_transform)
     surface->buffer_transform = state->buffer_transform;
@@ -978,8 +989,9 @@ meta_wayland_surface_commit (MetaWaylandSurface *surface)
       MetaMultiTexture *committed_texture = surface->committed_state.texture;
       int committed_scale = surface->committed_state.scale;
 
-      if ((meta_multi_texture_get_width (committed_texture) % committed_scale != 0) ||
-          (meta_multi_texture_get_height (committed_texture) % committed_scale != 0))
+      if (((meta_multi_texture_get_width (committed_texture) % committed_scale != 0) ||
+           (meta_multi_texture_get_height (committed_texture) % committed_scale != 0)) &&
+          !meta_wayland_surface_is_xwayland (surface))
         {
           if (surface->role && !META_IS_WAYLAND_CURSOR_SURFACE (surface->role))
             {
@@ -1507,6 +1519,16 @@ meta_wayland_surface_update_outputs (MetaWaylandSurface *surface)
   g_hash_table_foreach (surface->compositor->outputs,
                         update_surface_output_state,
                         surface);
+
+  if (meta_wayland_surface_is_xwayland (surface))
+    {
+#ifdef HAVE_XWAYLAND
+      MetaXWaylandManager *xwayland_manager =
+        &surface->compositor->xwayland_manager;
+
+      surface->applied_state.scale = meta_xwayland_get_effective_scale (xwayland_manager);
+#endif
+    }
 }
 
 void
diff --git a/src/wayland/meta-wayland-text-input-v1.c b/src/wayland/meta-wayland-text-input-v1.c
new file mode 100644
index 000000000..1826a4ff4
--- /dev/null
+++ b/src/wayland/meta-wayland-text-input-v1.c
@@ -0,0 +1,859 @@
+/*
+ * Copyright (C) 2024 SUSE LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Alynx Zhou <alynx.zhou@gmail.com>
+ */
+
+#include "config.h"
+#include "wayland/meta-wayland-text-input-v1.h"
+
+#include <wayland-server.h>
+
+#include "compositor/meta-surface-actor-wayland.h"
+#include "wayland/meta-wayland-private.h"
+#include "wayland/meta-wayland-seat.h"
+#include "wayland/meta-wayland-versions.h"
+
+#include "text-input-unstable-v1-server-protocol.h"
+
+/*
+ * Main difference between text-input-v1 and text-input-v3:
+ * text-input-v1 is not required to be double-buffered, we are expected to send
+ * response immediately after we receive requests, while text-input-v3 requires
+ * us to hold pending state and apply on commit, and all responses are applied
+ * after we send done.
+ *
+ * This implementation is incomplete, but it do make IME work.
+ *
+ * Things won't be implemented (Reminders for myself):
+ * - set_preferred_language (We don't have equivalence in ClutterInputMethod.)
+ * - invoke_action (No description about what button and index are.)
+ * - input_panel_state (We don't set this from ClutterInputFocus to text_input,
+ *   we only set this from text_input to ClutterInputFocus.)
+ * - cursor_position (We don't have equivalence in ClutterInputMethod.)
+ * - language (We don't have equivalence in ClutterInputMethod.)
+ * - text_direction (We don't have equivalence in ClutterInputMethod.)
+ * - keysym (This matches keysym request in input-method-v1, but we only have
+ *   forward_key in ClutterInputMethod, which is more like key request in
+ *   input-method-v1 and will finally become a keyboard key event, we don't have
+ *   equivalence for this in ClutterInputMethod.)
+ * - modifiers_map (This is used by keysym and we don't support keysym.)
+ */
+
+struct _MetaWaylandTextInputV1
+{
+  MetaWaylandSeat *seat;
+  ClutterInputFocus *input_focus;
+
+  struct wl_list resource_list;
+  struct wl_list focus_resource_list;
+  MetaWaylandSurface *surface;
+  struct wl_listener surface_listener;
+
+  GHashTable *resource_serials;
+
+  struct
+  {
+    char *text;
+    uint32_t cursor;
+    uint32_t anchor;
+  } surrounding;
+};
+
+#define META_TYPE_WAYLAND_TEXT_INPUT_V1_FOCUS (meta_wayland_text_input_v1_focus_get_type ())
+G_DECLARE_FINAL_TYPE (MetaWaylandTextInputV1Focus, meta_wayland_text_input_v1_focus,
+                      META, WAYLAND_TEXT_INPUT_V1_FOCUS, ClutterInputFocus)
+
+struct _MetaWaylandTextInputV1Focus
+{
+  ClutterInputFocus parent_instance;
+  MetaWaylandTextInputV1 *text_input;
+};
+G_DEFINE_TYPE (MetaWaylandTextInputV1Focus, meta_wayland_text_input_v1_focus,
+               CLUTTER_TYPE_INPUT_FOCUS)
+
+static MetaBackend *
+backend_from_text_input_v1 (MetaWaylandTextInputV1 *text_input)
+{
+  MetaWaylandSeat *seat = text_input->seat;
+  MetaWaylandCompositor *compositor = meta_wayland_seat_get_compositor (seat);
+  MetaContext *context = meta_wayland_compositor_get_context (compositor);
+
+  return meta_context_get_backend (context);
+}
+
+static uint32_t
+get_serial (MetaWaylandTextInputV1 *text_input,
+            struct wl_resource     *resource)
+{
+  return GPOINTER_TO_UINT (g_hash_table_lookup (text_input->resource_serials,
+                                                resource));
+}
+
+static void
+set_serial (MetaWaylandTextInputV1 *text_input,
+            struct wl_resource     *resource,
+            uint32_t                serial)
+{
+  g_hash_table_insert (text_input->resource_serials, resource,
+                       GUINT_TO_POINTER (serial));
+}
+
+static void
+text_input_v1_send_preedit_string (struct wl_resource *resource,
+                                   uint32_t            serial,
+                                   const char         *text,
+                                   unsigned int        cursor)
+{
+  gsize pos = 0;
+
+  /* Chromium does not accept NULL as preedit/commit string... */
+  text = text ? text : "";
+  pos = g_utf8_offset_to_pointer (text, cursor) - text;
+
+  /* We really don't need so much styles... */
+  zwp_text_input_v1_send_preedit_styling (resource, 0, strlen (text),
+                                          ZWP_TEXT_INPUT_V1_PREEDIT_STYLE_UNDERLINE);
+  zwp_text_input_v1_send_preedit_cursor (resource, pos);
+  zwp_text_input_v1_send_preedit_string (resource, serial, text, text);
+}
+
+static void
+meta_wayland_text_input_v1_focus_set_preedit_text (ClutterInputFocus *focus,
+                                                   const gchar       *text,
+                                                   unsigned int       cursor,
+                                                   unsigned int       anchor)
+{
+  MetaWaylandTextInputV1 *text_input;
+  struct wl_resource *resource;
+
+  text_input = META_WAYLAND_TEXT_INPUT_V1_FOCUS (focus)->text_input;
+
+  wl_resource_for_each (resource, &text_input->focus_resource_list)
+    {
+      text_input_v1_send_preedit_string (resource,
+                                         get_serial (text_input, resource),
+                                         text,
+                                         cursor);
+    }
+}
+
+static void
+meta_wayland_text_input_v1_focus_request_surrounding (ClutterInputFocus *focus)
+{
+  MetaWaylandTextInputV1 *text_input;
+  long cursor, anchor;
+
+  /* Clutter uses char offsets but text-input-v1 uses byte offsets. */
+  text_input = META_WAYLAND_TEXT_INPUT_V1_FOCUS (focus)->text_input;
+  cursor = g_utf8_strlen (text_input->surrounding.text,
+                          text_input->surrounding.cursor);
+  anchor = g_utf8_strlen (text_input->surrounding.text,
+                          text_input->surrounding.anchor);
+  clutter_input_focus_set_surrounding (focus,
+                                       text_input->surrounding.text,
+                                       cursor,
+                                       anchor);
+}
+
+static void
+text_input_v1_send_commit_string (struct wl_resource *resource,
+                                  uint32_t            serial,
+                                  const char         *text)
+{
+  /* Chromium does not accept NULL as preedit/commit string... */
+  text = text ? text : "";
+
+  zwp_text_input_v1_send_commit_string (resource, serial, text);
+}
+
+static void
+meta_wayland_text_input_v1_focus_delete_surrounding (ClutterInputFocus *focus,
+                                                     int                offset,
+                                                     guint              len)
+{
+  MetaWaylandTextInputV1 *text_input;
+  struct wl_resource *resource;
+  const char *start, *end;
+  const char *before, *after;
+  const char *cursor;
+
+  /*
+   * offset and len are counted by UTF-8 chars, but text-input-v1's lengths are
+   * counted by bytes, so we convert UTF-8 char offsets to pointers here, this
+   * needs the surrounding text
+   */
+  text_input = META_WAYLAND_TEXT_INPUT_V1_FOCUS (focus)->text_input;
+  offset = MIN (offset, 0);
+
+  start = text_input->surrounding.text;
+  end = start + strlen (text_input->surrounding.text);
+  cursor = start + text_input->surrounding.cursor;
+
+  before = g_utf8_offset_to_pointer (cursor, offset);
+  g_assert (before >= start);
+
+  after = g_utf8_offset_to_pointer (cursor, offset + len);
+  g_assert (after <= end);
+
+  wl_resource_for_each (resource, &text_input->focus_resource_list)
+    {
+      zwp_text_input_v1_send_delete_surrounding_text (resource,
+                                                      before - cursor,
+                                                      after - before);
+      /*
+       * text-input-v1 says delete_surrounding belongs to next commit, so an
+       * empty commit is required.
+       */
+      text_input_v1_send_commit_string (resource,
+                                        get_serial (text_input, resource),
+                                        NULL);
+    }
+}
+
+static void
+meta_wayland_text_input_v1_focus_commit_text (ClutterInputFocus *focus,
+                                              const gchar       *text)
+{
+  MetaWaylandTextInputV1 *text_input;
+  struct wl_resource *resource;
+
+  text_input = META_WAYLAND_TEXT_INPUT_V1_FOCUS (focus)->text_input;
+
+  wl_resource_for_each (resource, &text_input->focus_resource_list)
+    {
+      /*
+       * You have to clear preedit string after committing string, otherwise
+       * some apps (I reproduced with Code OSS) will send you empty surrounding
+       * text and breaks delete_surrounding_text.
+       */
+      text_input_v1_send_commit_string (resource,
+                                        get_serial (text_input, resource),
+                                        text);
+      /* Clear preedit string because we already committed. */
+      text_input_v1_send_preedit_string (resource,
+                                         get_serial (text_input, resource),
+                                         NULL,
+                                         0);
+    }
+}
+
+static void
+meta_wayland_text_input_v1_focus_class_init (MetaWaylandTextInputV1FocusClass *klass)
+{
+  ClutterInputFocusClass *focus_class = CLUTTER_INPUT_FOCUS_CLASS (klass);
+
+  focus_class->request_surrounding = meta_wayland_text_input_v1_focus_request_surrounding;
+  focus_class->delete_surrounding = meta_wayland_text_input_v1_focus_delete_surrounding;
+  focus_class->commit_text = meta_wayland_text_input_v1_focus_commit_text;
+  focus_class->set_preedit_text = meta_wayland_text_input_v1_focus_set_preedit_text;
+}
+
+static void
+meta_wayland_text_input_v1_focus_init (MetaWaylandTextInputV1Focus *focus)
+{
+}
+
+static ClutterInputFocus *
+meta_wayland_text_input_focus_new (MetaWaylandTextInputV1 *text_input)
+{
+  MetaWaylandTextInputV1Focus *focus;
+
+  focus = g_object_new (META_TYPE_WAYLAND_TEXT_INPUT_V1_FOCUS, NULL);
+  focus->text_input = text_input;
+
+  return CLUTTER_INPUT_FOCUS (focus);
+}
+
+static void
+move_resources (struct wl_list *destination, struct wl_list *source)
+{
+  wl_list_insert_list (destination, source);
+  wl_list_init (source);
+}
+
+static void
+move_resources_for_client (struct wl_list *destination,
+                           struct wl_list *source,
+                           struct wl_client *client)
+{
+  struct wl_resource *resource, *tmp;
+  wl_resource_for_each_safe (resource, tmp, source)
+    {
+      if (wl_resource_get_client (resource) == client)
+        {
+          wl_list_remove (wl_resource_get_link (resource));
+          wl_list_insert (destination, wl_resource_get_link (resource));
+        }
+    }
+}
+
+static void
+meta_wayland_text_input_v1_set_focus (MetaWaylandTextInputV1 *text_input,
+                                      MetaWaylandSurface     *surface)
+{
+  if (text_input->surface == surface)
+    return;
+
+  if (text_input->surface)
+    {
+      if (!wl_list_empty (&text_input->focus_resource_list))
+        {
+          ClutterInputFocus *focus = text_input->input_focus;
+          ClutterInputMethod *input_method;
+          struct wl_resource *resource;
+
+          if (clutter_input_focus_is_focused (focus))
+            {
+              input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
+              clutter_input_focus_reset (focus);
+              clutter_input_method_focus_out (input_method);
+            }
+
+          wl_resource_for_each (resource, &text_input->focus_resource_list)
+            {
+              zwp_text_input_v1_send_leave (resource);
+            }
+
+          move_resources (&text_input->resource_list,
+                          &text_input->focus_resource_list);
+        }
+
+      wl_list_remove (&text_input->surface_listener.link);
+      text_input->surface = NULL;
+    }
+
+  if (surface && surface->resource)
+    {
+      struct wl_resource *focus_surface_resource;
+
+      text_input->surface = surface;
+      focus_surface_resource = text_input->surface->resource;
+      wl_resource_add_destroy_listener (focus_surface_resource,
+                                        &text_input->surface_listener);
+
+      move_resources_for_client (&text_input->focus_resource_list,
+                                 &text_input->resource_list,
+                                 wl_resource_get_client (focus_surface_resource));
+
+      if (!wl_list_empty (&text_input->focus_resource_list))
+        {
+          struct wl_resource *resource;
+
+          wl_resource_for_each (resource, &text_input->focus_resource_list)
+            {
+              zwp_text_input_v1_send_enter (resource, surface->resource);
+            }
+        }
+    }
+}
+
+static void
+text_input_v1_handle_focus_surface_destroy (struct wl_listener *listener,
+                                            void               *data)
+{
+  MetaWaylandTextInputV1 *text_input = wl_container_of (listener, text_input, surface_listener);
+
+  meta_wayland_text_input_v1_set_focus (text_input, NULL);
+}
+
+static void
+text_input_v1_destructor (struct wl_resource *resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+
+  g_hash_table_remove (text_input->resource_serials, resource);
+  wl_list_remove (wl_resource_get_link (resource));
+}
+
+static gboolean
+client_matches_focus (MetaWaylandTextInputV1 *text_input,
+                      struct wl_client       *client)
+{
+  if (!text_input->surface)
+    return FALSE;
+
+  return client == wl_resource_get_client (text_input->surface->resource);
+}
+
+static void
+text_input_v1_activate (struct wl_client   *client,
+                        struct wl_resource *resource,
+                        struct wl_resource *seat_resource,
+                        struct wl_resource *surface_resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  MetaWaylandSurface *surface;
+  ClutterInputFocus *focus = text_input->input_focus;
+  ClutterInputMethod *input_method;
+
+  /*
+   * Don't use client_matches_focus() here because we have no focused surface if
+   * not activated in text-input-v1.
+   */
+
+  surface = wl_resource_get_user_data (surface_resource);
+  meta_wayland_text_input_v1_set_focus (text_input, surface);
+
+  input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
+
+  if (input_method)
+    {
+      if (!clutter_input_focus_is_focused (focus))
+        clutter_input_method_focus_in (input_method, focus);
+
+      clutter_input_focus_set_can_show_preedit (focus, TRUE);
+    }
+}
+
+static void
+text_input_v1_deactivate (struct wl_client   *client,
+                          struct wl_resource *resource,
+                          struct wl_resource *seat_resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+  ClutterInputMethod *input_method;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  meta_wayland_text_input_v1_set_focus (text_input, NULL);
+
+  input_method = clutter_backend_get_input_method (clutter_get_default_backend ());
+  if (input_method && clutter_input_focus_is_focused (focus))
+    {
+      clutter_input_focus_reset (focus);
+      clutter_input_method_focus_out (input_method);
+    }
+}
+
+static void
+text_input_v1_show_input_panel (struct wl_client   *client,
+                                struct wl_resource *resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  clutter_input_focus_set_input_panel_state (focus,
+                                             CLUTTER_INPUT_PANEL_STATE_ON);
+}
+
+static void
+text_input_v1_hide_input_panel (struct wl_client   *client,
+                                struct wl_resource *resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  clutter_input_focus_set_input_panel_state (focus,
+                                             CLUTTER_INPUT_PANEL_STATE_OFF);
+}
+
+static void
+text_input_v1_set_surrounding_text (struct wl_client   *client,
+                                    struct wl_resource *resource,
+                                    const char         *text,
+                                    uint32_t            cursor,
+                                    uint32_t            anchor)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+  long char_cursor, char_anchor;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  /* Save the surrounding text for `delete_surrounding_text`. */
+  g_free (text_input->surrounding.text);
+  text_input->surrounding.text = g_strdup (text);
+  text_input->surrounding.cursor = cursor;
+  text_input->surrounding.anchor = anchor;
+
+  /* Pass the surrounding text to Clutter to handle it with input method. */
+  /* Clutter uses char offsets but text-input-v1 uses byte offsets. */
+  char_cursor = g_utf8_strlen (text_input->surrounding.text,
+                               text_input->surrounding.cursor);
+  char_anchor = g_utf8_strlen (text_input->surrounding.text,
+                               text_input->surrounding.anchor);
+  clutter_input_focus_set_surrounding (focus,
+                                       text_input->surrounding.text,
+                                       char_cursor,
+                                       char_anchor);
+}
+
+static void
+text_input_v1_reset (struct wl_client   *client,
+                     struct wl_resource *resource)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  /*
+   * This means text was changed outside of normal input method flow, but we are
+   * still focusing the same text entry, so we only reset states, but don't
+   * reset focus, cursor position and panel visibility.
+   */
+  g_clear_pointer (&text_input->surrounding.text, g_free);
+  clutter_input_focus_set_surrounding (focus, NULL, 0, 0);
+  clutter_input_focus_set_content_hints (focus, 0);
+  clutter_input_focus_set_content_purpose (focus,
+                                           CLUTTER_INPUT_CONTENT_PURPOSE_NORMAL);
+}
+
+static ClutterInputContentHintFlags
+translate_hints (uint32_t hints)
+{
+  ClutterInputContentHintFlags clutter_hints = 0;
+
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_DEFAULT)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_DEFAULT;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_PASSWORD)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_PASSWORD;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_AUTO_COMPLETION)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_COMPLETION;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_AUTO_CORRECTION)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_AUTO_CORRECTION;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_AUTO_CAPITALIZATION)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_AUTO_CAPITALIZATION;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_LOWERCASE)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_LOWERCASE;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_UPPERCASE)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_UPPERCASE;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_TITLECASE)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_TITLECASE;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_HIDDEN_TEXT)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_HIDDEN_TEXT;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_SENSITIVE_DATA)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_SENSITIVE_DATA;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_LATIN)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_LATIN;
+  if (hints & ZWP_TEXT_INPUT_V1_CONTENT_HINT_MULTILINE)
+    clutter_hints |= CLUTTER_INPUT_CONTENT_HINT_MULTILINE;
+
+  return clutter_hints;
+}
+
+static ClutterInputContentPurpose
+translate_purpose (uint32_t purpose)
+{
+  switch (purpose)
+    {
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_NORMAL:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_NORMAL;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_ALPHA:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_ALPHA;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_DIGITS:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_DIGITS;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_NUMBER:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_NUMBER;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_PHONE:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_PHONE;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_URL:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_URL;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_EMAIL:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_EMAIL;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_NAME:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_NAME;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_PASSWORD:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_PASSWORD;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_DATE:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_DATE;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_TIME:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_TIME;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_DATETIME:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_DATETIME;
+    case ZWP_TEXT_INPUT_V1_CONTENT_PURPOSE_TERMINAL:
+      return CLUTTER_INPUT_CONTENT_PURPOSE_TERMINAL;
+    }
+
+  g_warn_if_reached ();
+  return CLUTTER_INPUT_CONTENT_PURPOSE_NORMAL;
+}
+
+static void
+text_input_v1_set_content_type (struct wl_client   *client,
+                                struct wl_resource *resource,
+                                uint32_t            hint,
+                                uint32_t            purpose)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  clutter_input_focus_set_content_hints (focus, translate_hints (hint));
+  clutter_input_focus_set_content_purpose (focus, translate_purpose (purpose));
+}
+
+static void
+text_input_v1_set_cursor_rectangle (struct wl_client   *client,
+                                    struct wl_resource *resource,
+                                    int32_t             x,
+                                    int32_t             y,
+                                    int32_t             width,
+                                    int32_t             height)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+  ClutterInputFocus *focus = text_input->input_focus;
+  MtkRectangle rect = (MtkRectangle) { x, y, width, height };
+  graphene_rect_t cursor_rect;
+  float x1, y1, x2, y2;
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  meta_wayland_surface_get_absolute_coordinates (text_input->surface,
+                                                 rect.x, rect.y, &x1, &y1);
+  meta_wayland_surface_get_absolute_coordinates (text_input->surface,
+                                                 rect.x + rect.width,
+                                                 rect.y + rect.height,
+                                                 &x2, &y2);
+
+  graphene_rect_init (&cursor_rect, x1, y1, x2 - x1, y2 - y1);
+  clutter_input_focus_set_cursor_location (focus, &cursor_rect);
+}
+
+static void
+text_input_v1_set_preferred_lanaguage (struct wl_client   *client,
+                                       struct wl_resource *resource,
+                                       const char         *language)
+{
+  /* ClutterInputMethod does not support this so this is useless. */
+}
+
+/*
+ * text-input-v1 is not required to be double-buffered!!!!!!!!!!!!!!!!!!!!!!!!!!
+ * commit_state just means "I am giving you a new serial and you should use
+ * this". It can work without commit_state, chromium does not send this.
+ */
+static void
+text_input_v1_commit_state (struct wl_client   *client,
+                            struct wl_resource *resource,
+                            uint32_t            serial)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+
+  if (!client_matches_focus (text_input, client))
+    return;
+
+  set_serial (text_input, resource, serial);
+}
+
+static void
+text_input_v1_invoke_action (struct wl_client   *client,
+                             struct wl_resource *resource,
+                             uint32_t            button,
+                             uint32_t            index)
+{
+  /* There is no doc about what button and index are, I am not an invoker. */
+}
+
+static struct zwp_text_input_v1_interface meta_text_input_v1_interface = {
+  text_input_v1_activate,
+  text_input_v1_deactivate,
+  text_input_v1_show_input_panel,
+  text_input_v1_hide_input_panel,
+  text_input_v1_reset,
+  text_input_v1_set_surrounding_text,
+  text_input_v1_set_content_type,
+  text_input_v1_set_cursor_rectangle,
+  text_input_v1_set_preferred_lanaguage,
+  text_input_v1_commit_state,
+  text_input_v1_invoke_action
+};
+
+void
+meta_wayland_text_input_v1_destroy (MetaWaylandTextInputV1 *text_input)
+{
+  meta_wayland_text_input_v1_set_focus (text_input, NULL);
+  g_object_unref (text_input->input_focus);
+  g_hash_table_destroy (text_input->resource_serials);
+  g_clear_pointer (&text_input->surrounding.text, g_free);
+  g_free (text_input);
+}
+
+static void
+meta_wayland_text_input_v1_create_new_resource (MetaWaylandTextInputV1 *text_input,
+                                                struct wl_client       *client,
+                                                uint32_t                id)
+{
+  struct wl_resource *text_input_resource;
+
+  text_input_resource = wl_resource_create (client,
+                                            &zwp_text_input_v1_interface,
+                                            META_ZWP_TEXT_INPUT_V1_VERSION,
+                                            id);
+
+  wl_resource_set_implementation (text_input_resource,
+                                  &meta_text_input_v1_interface,
+                                  text_input, text_input_v1_destructor);
+
+  if (text_input->surface &&
+      wl_resource_get_client (text_input->surface->resource) == client)
+    {
+      wl_list_insert (&text_input->focus_resource_list,
+                      wl_resource_get_link (text_input_resource));
+
+      zwp_text_input_v1_send_enter (text_input_resource,
+                                    text_input->surface->resource);
+    }
+  else
+    {
+      wl_list_insert (&text_input->resource_list,
+                      wl_resource_get_link (text_input_resource));
+    }
+}
+
+static void
+text_input_manager_v1_get_text_input (struct wl_client   *client,
+                                      struct wl_resource *resource,
+                                      uint32_t            id)
+{
+  MetaWaylandTextInputV1 *text_input = wl_resource_get_user_data (resource);
+
+  meta_wayland_text_input_v1_create_new_resource (text_input, client, id);
+}
+
+static struct zwp_text_input_manager_v1_interface meta_text_input_manager_v1_interface = {
+  text_input_manager_v1_get_text_input
+};
+
+static void
+bind_text_input_v1 (struct wl_client *client,
+                    void             *data,
+                    uint32_t          version,
+                    uint32_t          id)
+{
+  MetaWaylandTextInputV1 *text_input = data;
+  struct wl_resource *resource;
+
+  resource = wl_resource_create (client,
+                                 &zwp_text_input_manager_v1_interface,
+                                 META_ZWP_TEXT_INPUT_V1_VERSION,
+                                 id);
+  wl_resource_set_implementation (resource,
+                                  &meta_text_input_manager_v1_interface,
+                                  text_input, NULL);
+}
+
+gboolean
+meta_wayland_text_input_v1_init (MetaWaylandCompositor *compositor)
+{
+  return (wl_global_create (compositor->wayland_display,
+                            &zwp_text_input_manager_v1_interface,
+                            META_ZWP_TEXT_INPUT_V1_VERSION,
+                            compositor->seat->text_input_v1,
+                            bind_text_input_v1) != NULL);
+}
+
+MetaWaylandTextInputV1 *
+meta_wayland_text_input_v1_new (MetaWaylandSeat *seat)
+{
+  MetaWaylandTextInputV1 *text_input;
+
+  text_input = g_new0 (MetaWaylandTextInputV1, 1);
+  text_input->input_focus = meta_wayland_text_input_focus_new (text_input);
+  text_input->seat = seat;
+
+  wl_list_init (&text_input->resource_list);
+  wl_list_init (&text_input->focus_resource_list);
+  text_input->surface_listener.notify = text_input_v1_handle_focus_surface_destroy;
+
+  text_input->resource_serials = g_hash_table_new (NULL, NULL);
+
+  return text_input;
+}
+
+/* This function eats key events and will send them to input method. */
+gboolean
+meta_wayland_text_input_v1_update (MetaWaylandTextInputV1 *text_input,
+                                   const ClutterEvent     *event)
+{
+  ClutterInputFocus *focus = text_input->input_focus;
+  ClutterEventType event_type;
+
+  if (!text_input->surface || !clutter_input_focus_is_focused (focus))
+    return FALSE;
+
+  event_type = clutter_event_type (event);
+
+  if (event_type == CLUTTER_KEY_PRESS ||
+      event_type == CLUTTER_KEY_RELEASE)
+    {
+      gboolean filtered = FALSE;
+
+      filtered = clutter_input_focus_filter_event (focus, event);
+
+      return filtered;
+    }
+
+  return FALSE;
+}
+
+gboolean
+meta_wayland_text_input_v1_handle_event (MetaWaylandTextInputV1 *text_input,
+                                         const ClutterEvent     *event)
+{
+  ClutterInputFocus *focus = text_input->input_focus;
+  ClutterEventType event_type;
+  gboolean retval;
+
+  if (!text_input->surface || !clutter_input_focus_is_focused (focus))
+    return FALSE;
+
+  event_type = clutter_event_type (event);
+
+  retval = clutter_input_focus_process_event (focus, event);
+
+  if (event_type == CLUTTER_BUTTON_PRESS || event_type == CLUTTER_TOUCH_BEGIN)
+    {
+      MetaWaylandSurface *surface = NULL;
+      MetaBackend *backend;
+      ClutterStage *stage;
+      ClutterActor *actor;
+
+      backend = backend_from_text_input_v1 (text_input);
+      stage = CLUTTER_STAGE (meta_backend_get_stage (backend));
+
+      actor = clutter_stage_get_device_actor (stage,
+                                              clutter_event_get_device (event),
+                                              clutter_event_get_event_sequence (event));
+
+      if (META_IS_SURFACE_ACTOR_WAYLAND (actor))
+        {
+          MetaSurfaceActorWayland *actor_wayland =
+            META_SURFACE_ACTOR_WAYLAND (actor);
+
+          surface = meta_surface_actor_wayland_get_surface (actor_wayland);
+
+          if (surface == text_input->surface)
+            clutter_input_focus_reset (focus);
+        }
+    }
+
+  return retval;
+}
diff --git a/src/wayland/meta-wayland-text-input-v1.h b/src/wayland/meta-wayland-text-input-v1.h
new file mode 100644
index 000000000..79b1c0a54
--- /dev/null
+++ b/src/wayland/meta-wayland-text-input-v1.h
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2024 SUSE LLC
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of the
+ * License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author: Alynx Zhou <alynx.zhou@gmail.com>
+ */
+
+#pragma once
+
+#include <wayland-server.h>
+
+#include "meta/window.h"
+#include "wayland/meta-wayland-types.h"
+
+typedef struct _MetaWaylandTextInputV1 MetaWaylandTextInputV1;
+
+MetaWaylandTextInputV1 * meta_wayland_text_input_v1_new (MetaWaylandSeat *seat);
+void meta_wayland_text_input_v1_destroy (MetaWaylandTextInputV1 *text_input);
+
+gboolean meta_wayland_text_input_v1_init (MetaWaylandCompositor *compositor);
+
+gboolean meta_wayland_text_input_v1_update (MetaWaylandTextInputV1 *text_input,
+                                            const ClutterEvent     *event);
+
+gboolean meta_wayland_text_input_v1_handle_event (MetaWaylandTextInputV1 *text_input,
+                                                  const ClutterEvent     *event);
diff --git a/src/wayland/meta-wayland-versions.h b/src/wayland/meta-wayland-versions.h
index 900f30d78..a77b81461 100644
--- a/src/wayland/meta-wayland-versions.h
+++ b/src/wayland/meta-wayland-versions.h
@@ -49,6 +49,7 @@
 #define META_ZXDG_OUTPUT_V1_VERSION         3
 #define META_ZWP_XWAYLAND_KEYBOARD_GRAB_V1_VERSION 1
 #define META_ZWP_TEXT_INPUT_V3_VERSION      1
+#define META_ZWP_TEXT_INPUT_V1_VERSION      1
 #define META_WP_VIEWPORTER_VERSION          1
 #define META_ZWP_PRIMARY_SELECTION_V1_VERSION 1
 #define META_WP_PRESENTATION_VERSION        1
diff --git a/src/wayland/meta-wayland.c b/src/wayland/meta-wayland.c
index 501b69a91..0114823c1 100644
--- a/src/wayland/meta-wayland.c
+++ b/src/wayland/meta-wayland.c
@@ -865,6 +865,7 @@ meta_wayland_compositor_new (MetaContext *context)
   meta_wayland_keyboard_shortcuts_inhibit_init (compositor);
   meta_wayland_surface_inhibit_shortcuts_dialog_init ();
   meta_wayland_text_input_init (compositor);
+  meta_wayland_text_input_v1_init (compositor);
   meta_wayland_init_presentation_time (compositor);
   meta_wayland_activation_init (compositor);
   meta_wayland_transaction_init (compositor);
@@ -1124,6 +1125,12 @@ meta_wayland_compositor_get_text_input (MetaWaylandCompositor *compositor)
   return compositor->seat->text_input;
 }
 
+MetaWaylandTextInputV1 *
+meta_wayland_compositor_get_text_input_v1 (MetaWaylandCompositor *compositor)
+{
+  return compositor->seat->text_input_v1;
+}
+
 static void
 meta_wayland_compositor_update_focus (MetaWaylandCompositor *compositor,
                                       MetaWindow            *window)
diff --git a/src/wayland/meta-wayland.h b/src/wayland/meta-wayland.h
index 0a0476eba..c23e82cdc 100644
--- a/src/wayland/meta-wayland.h
+++ b/src/wayland/meta-wayland.h
@@ -26,6 +26,7 @@
 #include "meta/types.h"
 #include "meta/meta-wayland-compositor.h"
 #include "wayland/meta-wayland-text-input.h"
+#include "wayland/meta-wayland-text-input-v1.h"
 #include "wayland/meta-wayland-types.h"
 
 META_EXPORT_TEST
@@ -88,6 +89,7 @@ void                    meta_wayland_compositor_schedule_surface_association (Me
                                                                               MetaWindow            *window);
 
 MetaWaylandTextInput *  meta_wayland_compositor_get_text_input (MetaWaylandCompositor *compositor);
+MetaWaylandTextInputV1 *  meta_wayland_compositor_get_text_input_v1 (MetaWaylandCompositor *compositor);
 
 #ifdef HAVE_XWAYLAND
 void                    meta_wayland_compositor_notify_surface_id (MetaWaylandCompositor *compositor,
diff --git a/src/wayland/meta-window-xwayland.c b/src/wayland/meta-window-xwayland.c
index 1299a351c..5fb006962 100644
--- a/src/wayland/meta-window-xwayland.c
+++ b/src/wayland/meta-window-xwayland.c
@@ -27,8 +27,9 @@
 #include "x11/window-x11-private.h"
 #include "x11/xprops.h"
 #include "wayland/meta-window-xwayland.h"
-#include "wayland/meta-wayland.h"
+#include "wayland/meta-wayland-private.h"
 #include "wayland/meta-wayland-surface-private.h"
+#include "wayland/meta-xwayland.h"
 
 enum
 {
@@ -315,6 +316,72 @@ meta_window_xwayland_process_property_notify (MetaWindow     *window,
     meta_window_queue (window, META_QUEUE_MOVE_RESIZE);
 }
 
+static void
+meta_window_xwayland_stage_to_protocol (MetaWindowX11 *window_x11,
+                                        int            stage_x,
+                                        int            stage_y,
+                                        int            stage_width,
+                                        int            stage_height,
+                                        int           *protocol_x,
+                                        int           *protocol_y,
+                                        int           *protocol_width,
+                                        int           *protocol_height)
+{
+  MetaDisplay *display = meta_window_get_display (META_WINDOW (window_x11));
+  MetaContext *context = meta_display_get_context (display);
+  MetaWaylandCompositor *wayland_compositor =
+    meta_context_get_wayland_compositor (context);
+  MetaXWaylandManager *xwayland_manager = &wayland_compositor->xwayland_manager;
+  int scale;
+
+  scale = meta_xwayland_get_effective_scale (xwayland_manager);
+  if (protocol_x)
+    *protocol_x = stage_x * scale;
+  if (protocol_y)
+    *protocol_y = stage_y * scale;
+  if (protocol_width)
+    *protocol_width = stage_width * scale;
+  if (protocol_height)
+    *protocol_height = stage_height * scale;
+}
+
+static void
+meta_window_xwayland_protocol_to_stage (MetaWindowX11 *window_x11,
+                                        int            protocol_x,
+                                        int            protocol_y,
+                                        int            protocol_width,
+                                        int            protocol_height,
+                                        int           *stage_x,
+                                        int           *stage_y,
+                                        int           *stage_width,
+                                        int           *stage_height)
+{
+  MetaDisplay *display = meta_window_get_display (META_WINDOW (window_x11));
+  MetaContext *context = meta_display_get_context (display);
+  MetaWaylandCompositor *wayland_compositor =
+    meta_context_get_wayland_compositor (context);
+  MetaXWaylandManager *xwayland_manager = &wayland_compositor->xwayland_manager;
+  MtkRectangle rect;
+  int scale;
+
+  rect.x = protocol_x;
+  rect.y = protocol_y;
+  rect.width = protocol_width;
+  rect.height = protocol_height;
+
+  scale = meta_xwayland_get_effective_scale (xwayland_manager);
+  mtk_rectangle_scale_double (&rect, 1.0 / scale, MTK_ROUNDING_STRATEGY_GROW, &rect);
+
+  if (stage_x)
+    *stage_x = rect.x;
+  if (stage_y)
+    *stage_y = rect.y;
+  if (stage_width)
+    *stage_width = rect.width;
+  if (stage_height)
+    *stage_height = rect.height;
+}
+
 static void
 meta_window_xwayland_class_init (MetaWindowXwaylandClass *klass)
 {
@@ -331,6 +398,8 @@ meta_window_xwayland_class_init (MetaWindowXwaylandClass *klass)
   window_x11_class->thaw_commits = meta_window_xwayland_thaw_commits;
   window_x11_class->always_update_shape = meta_window_xwayland_always_update_shape;
   window_x11_class->process_property_notify = meta_window_xwayland_process_property_notify;
+  window_x11_class->stage_to_protocol = meta_window_xwayland_stage_to_protocol;
+  window_x11_class->protocol_to_stage = meta_window_xwayland_protocol_to_stage;
 
   gobject_class->get_property = meta_window_xwayland_get_property;
   gobject_class->set_property = meta_window_xwayland_set_property;
diff --git a/src/wayland/meta-xwayland-private.h b/src/wayland/meta-xwayland-private.h
index 7a9cb73fd..9e06f0315 100644
--- a/src/wayland/meta-xwayland-private.h
+++ b/src/wayland/meta-xwayland-private.h
@@ -20,6 +20,7 @@
 #include <glib.h>
 
 #include "wayland/meta-wayland-private.h"
+#include "wayland/meta-xwayland.h"
 
 gboolean
 meta_xwayland_init (MetaXWaylandManager    *manager,
diff --git a/src/wayland/meta-xwayland-surface.c b/src/wayland/meta-xwayland-surface.c
index 8fa1c72a9..c6daf9b26 100644
--- a/src/wayland/meta-xwayland-surface.c
+++ b/src/wayland/meta-xwayland-surface.c
@@ -163,13 +163,19 @@ meta_xwayland_surface_get_relative_coordinates (MetaWaylandSurfaceRole *surface_
                                                 float                  *out_sy)
 {
   MetaXwaylandSurface *xwayland_surface = META_XWAYLAND_SURFACE (surface_role);
+  MetaWaylandSurface *surface =
+    meta_wayland_surface_role_get_surface (surface_role);
+  MetaWaylandCompositor *compositor =
+    meta_wayland_surface_get_compositor (surface);
   MtkRectangle window_rect = { 0 };
+  int xwayland_scale;
 
   if (xwayland_surface->window)
     meta_window_get_buffer_rect (xwayland_surface->window, &window_rect);
 
-  *out_sx = abs_x - window_rect.x;
-  *out_sy = abs_y - window_rect.y;
+  xwayland_scale = meta_xwayland_get_effective_scale (&compositor->xwayland_manager);
+  *out_sx = (abs_x - window_rect.x) * xwayland_scale;
+  *out_sy = (abs_y - window_rect.y) * xwayland_scale;
 }
 
 static MetaWaylandSurface *
diff --git a/src/wayland/meta-xwayland.c b/src/wayland/meta-xwayland.c
index 7f2915cfe..f6f9d01ff 100644
--- a/src/wayland/meta-xwayland.c
+++ b/src/wayland/meta-xwayland.c
@@ -1051,6 +1051,29 @@ meta_xwayland_shutdown (MetaWaylandCompositor *compositor)
     }
 }
 
+static void
+update_highest_monitor_scale (MetaXWaylandManager *manager)
+{
+  MetaWaylandCompositor *compositor = manager->compositor;
+  MetaContext *context = meta_wayland_compositor_get_context (compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  GList *logical_monitors;
+  GList *l;
+  double scale = 1.0;
+
+  logical_monitors = meta_monitor_manager_get_logical_monitors (monitor_manager);
+  for (l = logical_monitors; l; l = l->next)
+    {
+      MetaLogicalMonitor *logical_monitor = l->data;
+
+      scale = MAX (scale, meta_logical_monitor_get_scale (logical_monitor));
+    }
+
+  manager->highest_monitor_scale = scale;
+}
+
 gboolean
 meta_xwayland_init (MetaXWaylandManager    *manager,
                     MetaWaylandCompositor  *compositor,
@@ -1058,6 +1081,9 @@ meta_xwayland_init (MetaXWaylandManager    *manager,
                     GError                **error)
 {
   MetaContext *context = compositor->context;
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
   MetaX11DisplayPolicy policy;
   int display = 0;
 
@@ -1121,6 +1147,10 @@ meta_xwayland_init (MetaXWaylandManager    *manager,
   /* Xwayland specific protocol, needs to be filtered out for all other clients */
   meta_xwayland_grab_keyboard_init (compositor);
 
+  g_signal_connect_swapped (monitor_manager, "monitors-changed-internal",
+                            G_CALLBACK (update_highest_monitor_scale), manager);
+  update_highest_monitor_scale (manager);
+
   return TRUE;
 }
 
@@ -1313,3 +1343,29 @@ meta_xwayland_set_should_enable_ei_portal (MetaXWaylandManager  *manager,
 {
   manager->should_enable_ei_portal = should_enable_ei_portal;
 }
+
+int
+meta_xwayland_get_effective_scale (MetaXWaylandManager *manager)
+{
+  MetaWaylandCompositor *compositor = manager->compositor;
+  MetaContext *context = meta_wayland_compositor_get_context (compositor);
+  MetaBackend *backend = meta_context_get_backend (context);
+  MetaMonitorManager *monitor_manager =
+    meta_backend_get_monitor_manager (backend);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+
+  switch (meta_monitor_manager_get_layout_mode (monitor_manager))
+    {
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_PHYSICAL:
+      break;
+
+    case META_LOGICAL_MONITOR_LAYOUT_MODE_LOGICAL:
+      if (meta_settings_is_experimental_feature_enabled (settings,
+                                                         META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING) &&
+          meta_settings_is_experimental_feature_enabled (settings,
+                                                         META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER))
+        return ceil (manager->highest_monitor_scale);
+    }
+
+  return 1;
+}
diff --git a/src/wayland/meta-xwayland.h b/src/wayland/meta-xwayland.h
index daf9d1abb..ae7a06977 100644
--- a/src/wayland/meta-xwayland.h
+++ b/src/wayland/meta-xwayland.h
@@ -48,3 +48,5 @@ META_EXPORT_TEST
 gboolean meta_xwayland_signal (MetaXWaylandManager  *manager,
                                int                   signum,
                                GError              **error);
+
+int meta_xwayland_get_effective_scale (MetaXWaylandManager *manager);
diff --git a/src/x11/meta-x11-display.c b/src/x11/meta-x11-display.c
index 65eb217aa..024374e7e 100644
--- a/src/x11/meta-x11-display.c
+++ b/src/x11/meta-x11-display.c
@@ -70,7 +70,7 @@
 #include "wayland/meta-xwayland-private.h"
 #endif
 
-G_DEFINE_TYPE (MetaX11Display, meta_x11_display, G_TYPE_OBJECT)
+#include "meta-dbus-x11.h"
 
 static GQuark quark_x11_display_logical_monitor_data = 0;
 
@@ -89,6 +89,14 @@ typedef struct _MetaX11DisplayLogicalMonitorData
   int xinerama_index;
 } MetaX11DisplayLogicalMonitorData;
 
+typedef struct _MetaX11DisplayPrivate
+{
+  MetaDBusX11 *dbus_api;
+  guint dbus_name_id;
+} MetaX11DisplayPrivate;
+
+G_DEFINE_TYPE_WITH_PRIVATE (MetaX11Display, meta_x11_display, G_TYPE_OBJECT)
+
 static char *get_screen_name (Display *xdisplay,
                               int      number);
 
@@ -122,6 +130,42 @@ backend_from_x11_display (MetaX11Display *x11_display)
   return meta_context_get_backend (context);
 }
 
+static void
+stage_to_protocol (MetaX11Display *x11_display,
+                   int             stage_x,
+                   int             stage_y,
+                   int            *protocol_x,
+                   int            *protocol_y)
+{
+  MetaDisplay *display = meta_x11_display_get_display (x11_display);
+  MetaContext *context = meta_display_get_context (display);
+  int scale = 1;
+
+  switch (meta_context_get_compositor_type (context))
+    {
+    case META_COMPOSITOR_TYPE_WAYLAND:
+      {
+#ifdef HAVE_XWAYLAND
+        MetaWaylandCompositor *wayland_compositor =
+          meta_context_get_wayland_compositor (context);
+        MetaXWaylandManager *xwayland_manager =
+          &wayland_compositor->xwayland_manager;
+
+        scale = meta_xwayland_get_effective_scale (xwayland_manager);
+#endif
+        break;
+      }
+
+    case META_COMPOSITOR_TYPE_X11:
+      break;
+    }
+
+  if (protocol_x)
+    *protocol_x = stage_x * scale;
+  if (protocol_y)
+    *protocol_y = stage_y * scale;
+}
+
 static void
 meta_x11_display_unmanage_windows (MetaX11Display *x11_display)
 {
@@ -151,13 +195,68 @@ meta_x11_event_filter_free (MetaX11EventFilter *filter)
   g_free (filter);
 }
 
+static void
+on_bus_acquired (GDBusConnection *connection,
+                 const char      *name,
+                 gpointer         user_data)
+{
+  MetaX11Display *x11_display = user_data;
+  MetaX11DisplayPrivate *priv =
+    meta_x11_display_get_instance_private (x11_display);
+
+  g_dbus_interface_skeleton_export (G_DBUS_INTERFACE_SKELETON (priv->dbus_api),
+                                    connection,
+                                    "/org/gnome/Mutter/X11",
+                                    NULL);
+}
+
+static void
+update_ui_scaling_factor (MetaX11Display *x11_display)
+{
+  MetaX11DisplayPrivate *priv =
+    meta_x11_display_get_instance_private (x11_display);
+  MetaBackend *backend = backend_from_x11_display (x11_display);
+  MetaContext *context = meta_backend_get_context (backend);
+  int ui_scaling_factor = 1;
+
+  switch (meta_context_get_compositor_type (context))
+    {
+    case META_COMPOSITOR_TYPE_WAYLAND:
+      {
+#ifdef HAVE_XWAYLAND
+        MetaWaylandCompositor *wayland_compositor =
+          meta_context_get_wayland_compositor (context);
+        MetaXWaylandManager *xwayland_manager =
+          &wayland_compositor->xwayland_manager;
+
+        ui_scaling_factor = meta_xwayland_get_effective_scale (xwayland_manager);
+#endif
+        break;
+      }
+    case META_COMPOSITOR_TYPE_X11:
+      {
+        MetaSettings *settings = meta_backend_get_settings (backend);
+
+        ui_scaling_factor = meta_settings_get_ui_scaling_factor (settings);
+        break;
+      }
+    }
+
+  meta_dbus_x11_set_ui_scaling_factor (priv->dbus_api, ui_scaling_factor);
+}
+
 static void
 meta_x11_display_dispose (GObject *object)
 {
   MetaX11Display *x11_display = META_X11_DISPLAY (object);
+  MetaX11DisplayPrivate *priv =
+    meta_x11_display_get_instance_private (x11_display);
 
   x11_display->closing = TRUE;
 
+  g_clear_handle_id (&priv->dbus_name_id, g_bus_unown_name);
+  g_clear_object (&priv->dbus_api);
+
   g_clear_pointer (&x11_display->alarm_filters, g_ptr_array_unref);
 
   g_clear_list (&x11_display->event_funcs,
@@ -596,6 +695,9 @@ set_desktop_geometry_hint (MetaX11Display *x11_display)
     return;
 
   meta_display_get_size (x11_display->display, &monitor_width, &monitor_height);
+  stage_to_protocol (x11_display,
+                     monitor_width, monitor_height,
+                     &monitor_width, &monitor_height);
 
   data[0] = monitor_width;
   data[1] = monitor_height;
@@ -1005,14 +1107,22 @@ set_workspace_work_area_hint (MetaWorkspace  *workspace,
 
   for (l = logical_monitors; l; l = l->next)
     {
-      MtkRectangle area;
+      MtkRectangle stage_area;
+      MtkRectangle protocol_area;
 
-      meta_workspace_get_work_area_for_logical_monitor (workspace, l->data, &area);
+      meta_workspace_get_work_area_for_logical_monitor (workspace, l->data,
+                                                        &stage_area);
 
-      tmp[0] = area.x;
-      tmp[1] = area.y;
-      tmp[2] = area.width;
-      tmp[3] = area.height;
+      stage_to_protocol (x11_display,
+                         stage_area.x, stage_area.y,
+                         &protocol_area.x, &protocol_area.y);
+      stage_to_protocol (x11_display,
+                         stage_area.width, stage_area.height,
+                         &protocol_area.width, &protocol_area.height);
+      tmp[0] = protocol_area.x;
+      tmp[1] = protocol_area.y;
+      tmp[2] = protocol_area.width;
+      tmp[3] = protocol_area.height;
 
       tmp += 4;
     }
@@ -1041,7 +1151,6 @@ set_work_area_hint (MetaDisplay    *display,
   int num_workspaces;
   GList *l;
   unsigned long *data, *tmp;
-  MtkRectangle area;
 
   num_workspaces = meta_workspace_manager_get_n_workspaces (workspace_manager);
   data = g_new (unsigned long, num_workspaces * 4);
@@ -1050,14 +1159,22 @@ set_work_area_hint (MetaDisplay    *display,
   for (l = workspace_manager->workspaces; l; l = l->next)
     {
       MetaWorkspace *workspace = l->data;
+      MtkRectangle stage_area;
+      MtkRectangle protocol_area;
 
-      meta_workspace_get_work_area_all_monitors (workspace, &area);
+      meta_workspace_get_work_area_all_monitors (workspace, &stage_area);
       set_workspace_work_area_hint (workspace, x11_display);
 
-      tmp[0] = area.x;
-      tmp[1] = area.y;
-      tmp[2] = area.width;
-      tmp[3] = area.height;
+      stage_to_protocol (x11_display,
+                         stage_area.x, stage_area.y,
+                         &protocol_area.x, &protocol_area.y);
+      stage_to_protocol (x11_display,
+                         stage_area.width, stage_area.height,
+                         &protocol_area.width, &protocol_area.height);
+      tmp[0] = protocol_area.x;
+      tmp[1] = protocol_area.y;
+      tmp[2] = protocol_area.width;
+      tmp[3] = protocol_area.height;
 
       tmp += 4;
     }
@@ -1220,6 +1337,58 @@ meta_x11_display_init_frames_client (MetaX11Display *x11_display)
                            on_frames_client_died, x11_display);
 }
 
+static void
+initialize_dbus_interface (MetaX11Display *x11_display)
+{
+  MetaX11DisplayPrivate *priv =
+    meta_x11_display_get_instance_private (x11_display);
+
+  priv->dbus_api = meta_dbus_x11_skeleton_new ();
+  priv->dbus_name_id =
+    g_bus_own_name (G_BUS_TYPE_SESSION,
+                    "org.gnome.Mutter.X11",
+                    G_BUS_NAME_OWNER_FLAGS_NONE,
+                    on_bus_acquired,
+                    NULL, NULL,
+                    x11_display, NULL);
+  update_ui_scaling_factor (x11_display);
+}
+
+static void
+experimental_features_changed (MetaSettings           *settings,
+                               MetaExperimentalFeature old_experimental_features,
+                               MetaX11Display         *x11_display)
+{
+  gboolean was_xwayland_native_scaling;
+  gboolean was_stage_views_scaled;
+  gboolean is_xwayland_native_scaling;
+  gboolean is_stage_views_scaled;
+
+  was_xwayland_native_scaling =
+    !!(old_experimental_features &
+       META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING);
+  was_stage_views_scaled =
+    !!(old_experimental_features &
+       META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+
+  is_xwayland_native_scaling =
+    meta_settings_is_experimental_feature_enabled (
+      settings,
+      META_EXPERIMENTAL_FEATURE_XWAYLAND_NATIVE_SCALING);
+  is_stage_views_scaled =
+    meta_settings_is_experimental_feature_enabled (
+      settings,
+      META_EXPERIMENTAL_FEATURE_SCALE_MONITOR_FRAMEBUFFER);
+
+  if (is_xwayland_native_scaling != was_xwayland_native_scaling ||
+      is_stage_views_scaled != was_stage_views_scaled)
+    {
+      update_ui_scaling_factor (x11_display);
+      set_desktop_geometry_hint (x11_display);
+      set_work_area_hint (x11_display->display, x11_display);
+    }
+}
+
 /**
  * meta_x11_display_new:
  *
@@ -1238,6 +1407,7 @@ meta_x11_display_new (MetaDisplay  *display,
   MetaBackend *backend = meta_context_get_backend (context);
   MetaMonitorManager *monitor_manager =
     meta_backend_get_monitor_manager (backend);
+  MetaSettings *settings = meta_backend_get_settings (backend);
   g_autoptr (MetaX11Display) x11_display = NULL;
   Display *xdisplay;
   Screen *xscreen;
@@ -1314,6 +1484,8 @@ meta_x11_display_new (MetaDisplay  *display,
   x11_display = g_object_new (META_TYPE_X11_DISPLAY, NULL);
   x11_display->display = display;
 
+  initialize_dbus_interface (x11_display);
+
   /* here we use XDisplayName which is what the user
    * probably put in, vs. DisplayString(display) which is
    * canonicalized by XOpenDisplay()
@@ -1406,7 +1578,7 @@ meta_x11_display_new (MetaDisplay  *display,
                            "monitors-changed-internal",
                            G_CALLBACK (on_monitors_changed_internal),
                            x11_display,
-                           0);
+                           G_CONNECT_AFTER);
 
   init_leader_window (x11_display, &timestamp);
   x11_display->timestamp = timestamp;
@@ -1499,6 +1671,11 @@ meta_x11_display_new (MetaDisplay  *display,
 
   meta_prefs_add_listener (prefs_changed_callback, x11_display);
 
+  g_signal_connect_object (settings,
+                           "experimental-features-changed",
+                           G_CALLBACK (experimental_features_changed),
+                           x11_display, 0);
+
   set_work_area_hint (display, x11_display);
 
   g_signal_connect_object (display, "workareas-changed",
@@ -1712,16 +1889,12 @@ meta_x11_display_reload_cursor (MetaX11Display *x11_display)
 }
 
 static void
-set_cursor_theme (Display     *xdisplay,
-                  MetaBackend *backend)
+set_cursor_theme (Display    *xdisplay,
+                  const char *theme,
+                  int         size)
 {
-  MetaSettings *settings = meta_backend_get_settings (backend);
-  int scale;
-
-  scale = meta_settings_get_ui_scaling_factor (settings);
-  XcursorSetTheme (xdisplay, meta_prefs_get_cursor_theme ());
-  XcursorSetDefaultSize (xdisplay,
-                         meta_prefs_get_cursor_size () * scale);
+  XcursorSetTheme (xdisplay, theme);
+  XcursorSetDefaultSize (xdisplay, size);
 }
 
 static void
@@ -1773,8 +1946,37 @@ static void
 update_cursor_theme (MetaX11Display *x11_display)
 {
   MetaBackend *backend = backend_from_x11_display (x11_display);
+  MetaContext *context = meta_backend_get_context (backend);
+  MetaSettings *settings = meta_backend_get_settings (backend);
+  int scale = 1;
+  int size;
+  const char *theme;
+
+  switch (meta_context_get_compositor_type (context))
+    {
+    case META_COMPOSITOR_TYPE_WAYLAND:
+      {
+#ifdef HAVE_XWAYLAND
+        MetaWaylandCompositor *wayland_compositor =
+          meta_context_get_wayland_compositor (context);
+        MetaXWaylandManager *xwayland_manager =
+          &wayland_compositor->xwayland_manager;
 
-  set_cursor_theme (x11_display->xdisplay, backend);
+        scale = meta_xwayland_get_effective_scale (xwayland_manager);
+#endif
+        break;
+      }
+
+    case META_COMPOSITOR_TYPE_X11:
+      scale = meta_settings_get_ui_scaling_factor (settings);
+      break;
+    }
+
+  size = meta_prefs_get_cursor_size () * scale;
+
+  theme = meta_prefs_get_cursor_theme ();
+
+  set_cursor_theme (x11_display->xdisplay, theme, size);
   schedule_reload_x11_cursor (x11_display);
 
   if (META_IS_BACKEND_X11 (backend))
@@ -1782,7 +1984,7 @@ update_cursor_theme (MetaX11Display *x11_display)
       MetaBackendX11 *backend_x11 = META_BACKEND_X11 (backend);
       Display *xdisplay = meta_backend_x11_get_xdisplay (backend_x11);
 
-      set_cursor_theme (xdisplay, backend);
+      set_cursor_theme (xdisplay, theme, size);
       meta_backend_x11_reload_cursor (backend_x11);
     }
 }
@@ -1975,6 +2177,8 @@ on_monitors_changed_internal (MetaMonitorManager *monitor_manager,
     }
 
   x11_display->has_xinerama_indices = FALSE;
+
+  update_ui_scaling_factor (x11_display);
 }
 
 static Bool
diff --git a/src/x11/window-props.c b/src/x11/window-props.c
index c18b3eab5..494fbe843 100644
--- a/src/x11/window-props.c
+++ b/src/x11/window-props.c
@@ -305,10 +305,15 @@ reload_icon_geometry (MetaWindow    *window,
         {
           MtkRectangle geometry;
 
-          geometry.x = (int)value->v.cardinal_list.cardinals[0];
-          geometry.y = (int)value->v.cardinal_list.cardinals[1];
-          geometry.width = (int)value->v.cardinal_list.cardinals[2];
-          geometry.height = (int)value->v.cardinal_list.cardinals[3];
+          meta_window_x11_protocol_to_stage (META_WINDOW_X11 (window),
+                                             value->v.cardinal_list.cardinals[0],
+                                             value->v.cardinal_list.cardinals[1],
+                                             value->v.cardinal_list.cardinals[2],
+                                             value->v.cardinal_list.cardinals[3],
+                                             &geometry.x,
+                                             &geometry.y,
+                                             &geometry.width,
+                                             &geometry.height);
 
           meta_window_set_icon_geometry (window, &geometry);
         }
@@ -370,11 +375,24 @@ reload_gtk_frame_extents (MetaWindow    *window,
         }
       else
         {
+          int left, right, top, bottom;
           MetaFrameBorder extents;
-          extents.left   = (int)value->v.cardinal_list.cardinals[0];
-          extents.right  = (int)value->v.cardinal_list.cardinals[1];
-          extents.top    = (int)value->v.cardinal_list.cardinals[2];
-          extents.bottom = (int)value->v.cardinal_list.cardinals[3];
+
+          meta_window_x11_protocol_to_stage (META_WINDOW_X11 (window),
+                                             value->v.cardinal_list.cardinals[0],
+                                             value->v.cardinal_list.cardinals[1],
+                                             value->v.cardinal_list.cardinals[2],
+                                             value->v.cardinal_list.cardinals[3],
+                                             &left,
+                                             &right,
+                                             &top,
+                                             &bottom);
+
+          extents.left = left;
+          extents.right = right;
+          extents.top = top;
+          extents.bottom = bottom;
+
           meta_window_set_custom_frame_extents (window, &extents, initial);
         }
     }
@@ -678,10 +696,16 @@ reload_opaque_region (MetaWindow    *window,
         {
           MtkRectangle *rect = &rects[rect_index];
 
-          rect->x = region[i++];
-          rect->y = region[i++];
-          rect->width = region[i++];
-          rect->height = region[i++];
+          meta_window_x11_protocol_to_stage (META_WINDOW_X11 (window),
+                                             region[i + 0],
+                                             region[i + 1],
+                                             region[i + 2],
+                                             region[i + 3],
+                                             &rect->x,
+                                             &rect->y,
+                                             &rect->width,
+                                             &rect->height);
+          i += 4;
 
           rect_index++;
         }
@@ -1245,9 +1269,65 @@ meta_set_normal_hints (MetaWindow *window,
    * as if flags were zero
    */
   if (hints)
-    window->size_hints = *(MetaSizeHints*)(hints);
+    {
+      MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+
+      window->size_hints = *(MetaSizeHints *) hints;
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->x, hints->y,
+                                         hints->width, hints->height,
+                                         &window->size_hints.x,
+                                         &window->size_hints.y,
+                                         &window->size_hints.width,
+                                         &window->size_hints.height);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->min_width, hints->min_height,
+                                         0, 0,
+                                         &window->size_hints.min_width,
+                                         &window->size_hints.min_height,
+                                         NULL, NULL);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->max_width, hints->max_height,
+                                         0, 0,
+                                         &window->size_hints.max_width,
+                                         &window->size_hints.max_height,
+                                         NULL, NULL);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->width_inc, hints->height_inc,
+                                         0, 0,
+                                         &window->size_hints.width_inc,
+                                         &window->size_hints.height_inc,
+                                         NULL, NULL);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->min_aspect.x, hints->min_aspect.y,
+                                         0, 0,
+                                         &window->size_hints.min_aspect.x,
+                                         &window->size_hints.min_aspect.y,
+                                         NULL, NULL);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->max_aspect.x, hints->max_aspect.y,
+                                         0, 0,
+                                         &window->size_hints.max_aspect.x,
+                                         &window->size_hints.max_aspect.y,
+                                         NULL, NULL);
+
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         hints->base_width, hints->base_height,
+                                         0, 0,
+                                         &window->size_hints.base_width,
+                                         &window->size_hints.base_height,
+                                         NULL, NULL);
+    }
   else
-    window->size_hints.flags = 0;
+    {
+      window->size_hints.flags = 0;
+    }
 
   /* Put back saved ConfigureRequest. */
   window->size_hints.x = x;
diff --git a/src/x11/window-x11-private.h b/src/x11/window-x11-private.h
index c947744ee..cb862f0d7 100644
--- a/src/x11/window-x11-private.h
+++ b/src/x11/window-x11-private.h
@@ -125,6 +125,8 @@ gboolean meta_window_x11_has_pointer (MetaWindow *window);
 gboolean meta_window_x11_same_application (MetaWindow *window,
                                            MetaWindow *other_window);
 
+gboolean meta_window_x11_is_shaped (MetaWindow *window);
+
 void meta_window_x11_shutdown_group (MetaWindow *window);
 
 META_EXPORT
diff --git a/src/x11/window-x11.c b/src/x11/window-x11.c
index 443f40f28..c96356ea5 100644
--- a/src/x11/window-x11.c
+++ b/src/x11/window-x11.c
@@ -110,6 +110,113 @@ meta_window_x11_get_private (MetaWindowX11 *window_x11)
   return meta_window_x11_get_instance_private (window_x11);
 }
 
+static void
+meta_window_x11_real_stage_to_protocol (MetaWindowX11 *window_x11,
+                                        int            stage_x,
+                                        int            stage_y,
+                                        int            stage_width,
+                                        int            stage_height,
+                                        int           *protocol_x,
+                                        int           *protocol_y,
+                                        int           *protocol_width,
+                                        int           *protocol_height)
+{
+  if (protocol_x)
+    *protocol_x = stage_x;
+  if (protocol_y)
+    *protocol_y = stage_y;
+  if (protocol_width)
+    *protocol_width = stage_width;
+  if (protocol_height)
+    *protocol_height = stage_height;
+}
+
+static void
+meta_window_x11_real_protocol_to_stage (MetaWindowX11 *window_x11,
+                                        int            protocol_x,
+                                        int            protocol_y,
+                                        int            protocol_width,
+                                        int            protocol_height,
+                                        int           *stage_x,
+                                        int           *stage_y,
+                                        int           *stage_width,
+                                        int           *stage_height)
+{
+  if (stage_x)
+    *stage_x = protocol_x;
+  if (stage_y)
+    *stage_y = protocol_y;
+  if (stage_width)
+    *stage_width = protocol_width;
+  if (stage_height)
+    *stage_height = protocol_height;
+}
+
+void
+meta_window_x11_stage_to_protocol (MetaWindowX11 *window_x11,
+                                   int            stage_x,
+                                   int            stage_y,
+                                   int            stage_width,
+                                   int            stage_height,
+                                   int           *protocol_x,
+                                   int           *protocol_y,
+                                   int           *protocol_width,
+                                   int           *protocol_height)
+{
+  MetaWindowX11Class *klass = META_WINDOW_X11_GET_CLASS (window_x11);
+
+  klass->stage_to_protocol (window_x11,
+                            stage_x, stage_y,
+                            stage_width, stage_height,
+                            protocol_x, protocol_y,
+                            protocol_width, protocol_height);
+}
+
+void
+meta_window_x11_protocol_to_stage (MetaWindowX11 *window_x11,
+                                   int            protocol_x,
+                                   int            protocol_y,
+                                   int            protocol_width,
+                                   int            protocol_height,
+                                   int           *stage_x,
+                                   int           *stage_y,
+                                   int           *stage_width,
+                                   int           *stage_height)
+{
+  MetaWindowX11Class *klass = META_WINDOW_X11_GET_CLASS (window_x11);
+
+  klass->protocol_to_stage (window_x11,
+                            protocol_x, protocol_y,
+                            protocol_width, protocol_height,
+                            stage_x, stage_y,
+                            stage_width, stage_height);
+}
+
+static MtkRegion *
+region_protocol_to_stage (MtkRegion     *region,
+                          MetaWindowX11 *window_x11)
+{
+  int n_rects, i;
+  MtkRectangle *rects;
+  MtkRegion *scaled_region;
+
+  n_rects = mtk_region_num_rectangles (region);
+  MTK_RECTANGLE_CREATE_ARRAY_SCOPED (n_rects, rects);
+  for (i = 0; i < n_rects; i++)
+    {
+      rects[i] = mtk_region_get_rectangle (region, i);
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         rects[i].x, rects[i].y,
+                                         rects[i].width, rects[i].height,
+                                         &rects[i].x, &rects[i].y,
+                                         &rects[i].width, &rects[i].height);
+    }
+
+  scaled_region = mtk_region_create_rectangles (rects, n_rects);
+
+  return scaled_region;
+}
+
 static void
 send_icccm_message (MetaWindow *window,
                     Atom        atom,
@@ -254,8 +361,14 @@ send_configure_notify (MetaWindow *window)
   event.xconfigure.display = x11_display->xdisplay;
   event.xconfigure.event = priv->xwindow;
   event.xconfigure.window = priv->xwindow;
-  event.xconfigure.x = priv->client_rect.x - priv->border_width;
-  event.xconfigure.y = priv->client_rect.y - priv->border_width;
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     priv->client_rect.x - priv->border_width,
+                                     priv->client_rect.y - priv->border_width,
+                                     0, 0,
+                                     &event.xconfigure.x,
+                                     &event.xconfigure.y,
+                                     NULL, NULL);
+
   if (window->frame)
     {
       if (window->withdrawn)
@@ -267,19 +380,42 @@ send_configure_notify (MetaWindow *window)
 
           meta_frame_calc_borders (window->frame, &borders);
 
-          event.xconfigure.x = window->frame->rect.x + borders.invisible.left;
-          event.xconfigure.y = window->frame->rect.y + borders.invisible.top;
+          meta_window_x11_stage_to_protocol (window_x11,
+                                             window->frame->rect.x + borders.invisible.left,
+                                             window->frame->rect.y + borders.invisible.top,
+                                             0, 0,
+                                             &event.xconfigure.x,
+                                             &event.xconfigure.y,
+                                             NULL, NULL);
         }
       else
         {
+          int dx, dy;
+
           /* Need to be in root window coordinates */
-          event.xconfigure.x += window->frame->rect.x;
-          event.xconfigure.y += window->frame->rect.y;
+          meta_window_x11_stage_to_protocol (window_x11,
+                                             window->frame->rect.x,
+                                             window->frame->rect.y,
+                                             0, 0,
+                                             &dx,
+                                             &dy,
+                                             NULL, NULL);
+          event.xconfigure.x += dx;
+          event.xconfigure.y += dy;
         }
     }
-  event.xconfigure.width = priv->client_rect.width;
-  event.xconfigure.height = priv->client_rect.height;
-  event.xconfigure.border_width = priv->border_width; /* requested not actual */
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     priv->client_rect.width,
+                                     priv->client_rect.height,
+                                     0, 0,
+                                     &event.xconfigure.width,
+                                     &event.xconfigure.height,
+                                     NULL, NULL);
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     priv->border_width,
+                                     0, 0, 0,
+                                     &event.xconfigure.border_width,
+                                     NULL, NULL, NULL);
   event.xconfigure.above = None; /* FIXME */
   event.xconfigure.override_redirect = False;
 
@@ -1137,20 +1273,26 @@ static void
 update_net_frame_extents (MetaWindow *window)
 {
   MetaX11Display *x11_display = window->display->x11_display;
-
+  int left, right, top, bottom;
   unsigned long data[4];
   MetaFrameBorders borders;
   Window xwindow = meta_window_x11_get_xwindow (window);
 
   meta_frame_calc_borders (window->frame, &borders);
-  /* Left */
-  data[0] = borders.visible.left;
-  /* Right */
-  data[1] = borders.visible.right;
-  /* Top */
-  data[2] = borders.visible.top;
-  /* Bottom */
-  data[3] = borders.visible.bottom;
+  meta_window_x11_stage_to_protocol (META_WINDOW_X11 (window),
+                                     borders.visible.left,
+                                     borders.visible.right,
+                                     borders.visible.top,
+                                     borders.visible.bottom,
+                                     &left,
+                                     &right,
+                                     &top,
+                                     &bottom);
+
+  data[0] = left;
+  data[1] = right;
+  data[2] = top;
+  data[3] = bottom;
 
   meta_topic (META_DEBUG_GEOMETRY,
               "Setting _NET_FRAME_EXTENTS on managed window 0x%lx "
@@ -1482,10 +1624,11 @@ meta_window_x11_move_resize_internal (MetaWindow                *window,
     configure_frame_first = size_dx + size_dy >= 0;
 
   values.border_width = 0;
-  values.x = client_rect.x;
-  values.y = client_rect.y;
-  values.width = client_rect.width;
-  values.height = client_rect.height;
+  meta_window_x11_stage_to_protocol (window_x11,
+                                     client_rect.x, client_rect.y,
+                                     client_rect.width, client_rect.height,
+                                     &values.x, &values.y,
+                                     &values.width, &values.height);
 
   mask = 0;
   if (is_configure_request && priv->border_width != 0)
@@ -1591,6 +1734,10 @@ meta_window_x11_update_struts (MetaWindow *window)
               strut_begin = struts[4+(i*2)];
               strut_end   = struts[4+(i*2)+1];
 
+              meta_window_x11_protocol_to_stage (META_WINDOW_X11 (window),
+                                                 strut_begin, strut_end, thickness, 0,
+                                                 &strut_begin, &strut_end, &thickness, NULL);
+
               temp = g_new0 (MetaStrut, 1);
               temp->side = 1 << i; /* See MetaSide def.  Matches nicely, eh? */
               meta_display_get_size (window->display,
@@ -1655,6 +1802,10 @@ meta_window_x11_update_struts (MetaWindow *window)
               if (thickness == 0)
                 continue;
 
+              meta_window_x11_protocol_to_stage (META_WINDOW_X11 (window),
+                                                 thickness, 0, 0, 0,
+                                                 &thickness, NULL, NULL, NULL);
+
               temp = g_new0 (MetaStrut, 1);
               temp->side = 1 << i;
               meta_display_get_size (window->display,
@@ -2040,9 +2191,10 @@ static void
 meta_window_x11_constructed (GObject *object)
 {
   MetaWindow *window = META_WINDOW (object);
-  MetaWindowX11 *x11_window = META_WINDOW_X11 (object);
-  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (x11_window);
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (object);
+  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
   XWindowAttributes attrs = priv->attributes;
+  MtkRectangle rect;
 
   meta_verbose ("attrs->map_state = %d (%s)",
                 attrs.map_state,
@@ -2057,16 +2209,17 @@ meta_window_x11_constructed (GObject *object)
   window->client_type = META_WINDOW_CLIENT_TYPE_X11;
   window->override_redirect = attrs.override_redirect;
 
-  window->rect.x = attrs.x;
-  window->rect.y = attrs.y;
-  window->rect.width = attrs.width;
-  window->rect.height = attrs.height;
+  meta_window_x11_protocol_to_stage (window_x11,
+                                     attrs.x, attrs.y, attrs.width, attrs.height,
+                                     &rect.x, &rect.y, &rect.width, &rect.height);
+
+  window->rect = rect;
 
   /* size_hints are the "request" */
-  window->size_hints.x = attrs.x;
-  window->size_hints.y = attrs.y;
-  window->size_hints.width = attrs.width;
-  window->size_hints.height = attrs.height;
+  window->size_hints.x = rect.x;
+  window->size_hints.y = rect.y;
+  window->size_hints.width = rect.width;
+  window->size_hints.height = rect.height;
 
   window->depth = attrs.depth;
   priv->xvisual = attrs.visual;
@@ -2076,11 +2229,11 @@ meta_window_x11_constructed (GObject *object)
 
   window->decorated = TRUE;
   window->hidden = FALSE;
-  priv->border_width = attrs.border_width;
   priv->xclient_leader = None;
 
-  priv->keys_grabbed = FALSE;
-  priv->grab_on_frame = FALSE;
+  meta_window_x11_protocol_to_stage (window_x11,
+                                     attrs.border_width, 0, 0, 0,
+                                     &priv->border_width, NULL, NULL, NULL);
 
   g_signal_connect (window, "notify::decorated",
                     G_CALLBACK (meta_window_x11_update_input_region),
@@ -2192,6 +2345,8 @@ meta_window_x11_class_init (MetaWindowX11Class *klass)
   klass->thaw_commits = meta_window_x11_impl_thaw_commits;
   klass->always_update_shape = meta_window_x11_impl_always_update_shape;
   klass->process_property_notify = meta_window_x11_impl_process_property_notify;
+  klass->stage_to_protocol = meta_window_x11_real_stage_to_protocol;
+  klass->protocol_to_stage = meta_window_x11_real_protocol_to_stage;
 
   obj_props[PROP_ATTRIBUTES] =
     g_param_spec_pointer ("attributes", NULL, NULL,
@@ -2418,8 +2573,13 @@ meta_window_x11_update_input_region (MetaWindow *window)
   else
     {
       xwindow = priv->xwindow;
-      bounding_rect.width = priv->client_rect.width;
-      bounding_rect.height = priv->client_rect.height;
+      meta_window_x11_stage_to_protocol(window_x11,
+                                        0, 0,
+                                        priv->client_rect.width,
+                                        priv->client_rect.height,
+                                        NULL, NULL,
+                                        &bounding_rect.width,
+                                        &bounding_rect.height);
     }
 
   if (META_X11_DISPLAY_HAS_SHAPE (x11_display))
@@ -2473,7 +2633,10 @@ meta_window_x11_update_input_region (MetaWindow *window)
       else
         {
           /* Window has a custom shape. */
-          region = region_create_from_x_rectangles (rects, n_rects);
+          g_autoptr (MtkRegion) protocol_region = NULL;
+
+          protocol_region = region_create_from_x_rectangles (rects, n_rects);
+          region = region_protocol_to_stage (protocol_region, window_x11);
         }
 
       meta_XFree (rects);
@@ -2549,7 +2712,10 @@ meta_window_x11_update_shape_region (MetaWindow *window)
 
       if (rects)
         {
-          region = region_create_from_x_rectangles (rects, n_rects);
+          g_autoptr (MtkRegion) protocol_region = NULL;
+
+          protocol_region = region_create_from_x_rectangles (rects, n_rects);
+          region = region_protocol_to_stage (protocol_region, window_x11);
           XFree (rects);
         }
     }
@@ -2582,6 +2748,15 @@ meta_window_x11_update_shape_region (MetaWindow *window)
   meta_window_set_shape_region (window, region);
 }
 
+gboolean
+meta_window_x11_is_shaped (MetaWindow *window)
+{
+  MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
+  MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+
+  return priv->shape_region != NULL;
+}
+
 /* Generally meta_window_x11_same_application() is a better idea
  * of "sameness", since it handles the case where multiple apps
  * want to look like the same app or the same app wants to look
@@ -2818,6 +2993,7 @@ meta_window_x11_configure_request (MetaWindow *window,
 {
   MetaWindowX11 *window_x11 = META_WINDOW_X11 (window);
   MetaWindowX11Private *priv = meta_window_x11_get_instance_private (window_x11);
+  int new_x, new_y, new_width, new_height;
 
   /* Note that x, y is the corner of the window border,
    * and width, height is the size of the window inside
@@ -2826,15 +3002,25 @@ meta_window_x11_configure_request (MetaWindow *window,
    * requested border here.
    */
   if (event->xconfigurerequest.value_mask & CWBorderWidth)
-    priv->border_width = event->xconfigurerequest.border_width;
+    {
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         event->xconfigurerequest.border_width, 0, 0, 0,
+                                         &priv->border_width, NULL, NULL, NULL);
+    }
+
+  meta_window_x11_protocol_to_stage (window_x11,
+                                     event->xconfigurerequest.x, event->xconfigurerequest.y,
+                                     event->xconfigurerequest.width, event->xconfigurerequest.height,
+                                     &new_x, &new_y,
+                                     &new_width, &new_height);
 
-  meta_window_move_resize_request(window,
-                                  event->xconfigurerequest.value_mask,
-                                  window->size_hints.win_gravity,
-                                  event->xconfigurerequest.x,
-                                  event->xconfigurerequest.y,
-                                  event->xconfigurerequest.width,
-                                  event->xconfigurerequest.height);
+  meta_window_move_resize_request (window,
+                                   event->xconfigurerequest.value_mask,
+                                   window->size_hints.win_gravity,
+                                   new_x,
+                                   new_y,
+                                   new_width,
+                                   new_height);
 
   /* Handle stacking. We only handle raises/lowers, mostly because
    * stack.c really can't deal with anything else.  I guess we'll fix
@@ -3330,8 +3516,13 @@ meta_window_x11_client_message (MetaWindow *window,
       guint32 timestamp;
       MetaWindowDrag *window_drag;
 
-      x_root = event->xclient.data.l[0];
-      y_root = event->xclient.data.l[1];
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         event->xclient.data.l[0],
+                                         event->xclient.data.l[1],
+                                         0, 0,
+                                         &x_root,
+                                         &y_root,
+                                         NULL, NULL);
       action = event->xclient.data.l[2];
       button = event->xclient.data.l[3];
 
@@ -3495,6 +3686,7 @@ meta_window_x11_client_message (MetaWindow *window,
     {
       MetaGravity gravity;
       guint value_mask;
+      int x, y, width, height;
 
       gravity = (MetaGravity) (event->xclient.data.l[0] & 0xff);
       value_mask = (event->xclient.data.l[0] & 0xf00) >> 8;
@@ -3503,13 +3695,20 @@ meta_window_x11_client_message (MetaWindow *window,
       if (gravity == 0)
         gravity = window->size_hints.win_gravity;
 
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         event->xclient.data.l[1],
+                                         event->xclient.data.l[2],
+                                         event->xclient.data.l[3],
+                                         event->xclient.data.l[4],
+                                         &x, &y, &width, &height);
+
       meta_window_move_resize_request(window,
                                       value_mask,
                                       gravity,
-                                      event->xclient.data.l[1],  /* x */
-                                      event->xclient.data.l[2],  /* y */
-                                      event->xclient.data.l[3],  /* width */
-                                      event->xclient.data.l[4]); /* height */
+                                      x,
+                                      y,
+                                      width,
+                                      height);
     }
   else if (event->xclient.message_type ==
            x11_display->atom__NET_ACTIVE_WINDOW &&
@@ -3566,11 +3765,15 @@ meta_window_x11_client_message (MetaWindow *window,
   else if (event->xclient.message_type ==
            x11_display->atom__GTK_SHOW_WINDOW_MENU)
     {
-      gulong x, y;
+      int x, y;
 
       /* l[0] is device_id, which we don't use */
-      x = event->xclient.data.l[1];
-      y = event->xclient.data.l[2];
+      meta_window_x11_protocol_to_stage (window_x11,
+                                         event->xclient.data.l[1],
+                                         event->xclient.data.l[2],
+                                         0, 0,
+                                         &x, &y,
+                                         NULL, NULL);
 
       meta_window_show_menu (window, META_WINDOW_MENU_WM, x, y);
     }
@@ -4092,10 +4295,11 @@ meta_window_x11_configure_notify (MetaWindow      *window,
   g_assert (window->override_redirect);
   g_assert (window->frame == NULL);
 
-  window->rect.x = event->x;
-  window->rect.y = event->y;
-  window->rect.width = event->width;
-  window->rect.height = event->height;
+  meta_window_x11_protocol_to_stage (window_x11,
+                                     event->x, event->y,
+                                     event->width, event->height,
+                                     &window->rect.x, &window->rect.y,
+                                     &window->rect.width, &window->rect.height);
 
   priv->client_rect = window->rect;
   window->buffer_rect = window->rect;
diff --git a/src/x11/window-x11.h b/src/x11/window-x11.h
index 205eaaa63..fa3fbea6a 100644
--- a/src/x11/window-x11.h
+++ b/src/x11/window-x11.h
@@ -45,6 +45,24 @@ struct _MetaWindowX11Class
   gboolean (*always_update_shape) (MetaWindow *window);
   void (*process_property_notify) (MetaWindow     *window,
                                    XPropertyEvent *event);
+  void (*stage_to_protocol) (MetaWindowX11 *window_x11,
+                             int            stage_x,
+                             int            stage_y,
+                             int            stage_width,
+                             int            stage_height,
+                             int           *protocol_x,
+                             int           *protocol_y,
+                             int           *protocol_width,
+                             int           *protocol_height);
+  void (*protocol_to_stage) (MetaWindowX11 *window_x11,
+                             int            protocol_x,
+                             int            protocol_y,
+                             int            protocol_width,
+                             int            protocol_height,
+                             int           *stage_x,
+                             int           *stage_y,
+                             int           *stage_width,
+                             int           *stage_height);
 };
 
 MetaWindow * meta_window_x11_new           (MetaDisplay        *display,
@@ -112,3 +130,23 @@ gboolean meta_window_x11_has_alpha_channel (MetaWindow *window);
 
 META_EXPORT
 Window meta_window_x11_get_xwindow (MetaWindow *window);
+
+void meta_window_x11_stage_to_protocol (MetaWindowX11 *window_x11,
+                                        int            stage_x,
+                                        int            stage_y,
+                                        int            stage_width,
+                                        int            stage_heigth,
+                                        int           *protocol_x,
+                                        int           *protocol_y,
+                                        int           *protocol_width,
+                                        int           *protocol_height);
+
+void meta_window_x11_protocol_to_stage (MetaWindowX11 *window_x11,
+                                        int            protocol_x,
+                                        int            protocol_y,
+                                        int            protocol_width,
+                                        int            protocol_height,
+                                        int           *stage_x,
+                                        int           *stage_y,
+                                        int           *stage_width,
+                                        int           *stage_heigth);
